<!DOCTYPE html>

<html id="html" lang="en">

<head id="head">

<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/>
<meta name="description" content="3D Spline Animation"/>
<meta name="author" content="Matthew Bullen"/>
<meta name="copyright" content="Copyright April 12, 2014 by Matthew Bullen, All Rights Reserved"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title id="title">3D DOM Animation</title>
<link id="favicon" rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAFpOLgnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAEzlAABM5QF1zvCVAAAFF0lEQVRo3t2aTWhcVRTHf+fNTJIaMIrGFPED/KhfC6ug6EJciIIghSoUQVyIuhBEKbhwZUS6KbgQcSfqRkRaRATRqrjTil1IQTGoVXFRFAkltqE0ycz7u5jzxpub9zmZfNgLh/fmvPvuPd/n3PPGJFE02tmNmQ1mSTKAJJzpyNvN7NlVb4ZvF74pybJJpW9aGbWFD9sxC9mSSUxEGeNHVj0YUBSTHe9TSNWqB2a2I3rek7S85i1JAwDUR63FAdMZrp27vdm03+4M0Kea7HTa8UsZLqF6POHXsSJBHIpe+Bv4CjgsqVcp1jq2fIHTPWDVechXXKzRaHQkddeYdWhVbitvOnrRzGyViAvEa8CKQ5KrSDMbA6Z88nHn85iktC4PPUmDhat4mASScLFSjUs6CxxzCh6tZNrxPX+2U1JtPQxcMpTSp8Bi8Psc8Luk2Vou2jjSjHTEgoncuy58nrdOBrmc5Ai6F3hKdu25E8cm0A79tDYnRRQCE8DbgVl0gdnMJwbzht3EfWcS+AFIfe5K3tx2Lesw6/miYYBJgZbje8AJSTfWtq4q4w/GEjDu96mLyeJJSU0LtAKYCBZNMgLN7JbGm9QYf0a/dw0jrvlAJ+bE7XBRpRGxK5LG6m6SVkkxuAroABdLWihMUTXxuRtloX9LY1fCJoy8bNipEFfGejdL2o2isFvOwYYReB7YC4wVxbg8ca00lMYlwGHg4/XoJPXY1PMo2/VwEtahLeA+M7t7UMY02ETAfklth47DBHCrbxaudTQKpLU5GS/A/+SbxTpOR2bC6p9mWhvqJ2bWWpNmYd4LwsbhYzI4DoTE7TOz1yP8VXUOJgYciPwgjSC0snDezUV+UocTq/g9KNs3InalQakE8J2ZfZmnkzp+8kJB6m0BL0Vr3QvsGYaTsjkHgX2R578x0lDvJvxJhJ7ZiHxy5SicMS1xyHFgLkLPDeMni54zMlgAzhTklmVg9zB+MulQp6j4A/ixjrjyvDwt8fwsjLwl6fq8sJLHyRzwQQnFXeCsi+0kcETSnJkltUsin2wN6i6poq7alLprcw6mW1HbFficjbDYVFRGa8MZMTPzjZ4CnnE/tyEI7wVwztc5BZw0s9/8tHm8pHIYjUaAq4HbnCjbEBvvV53LwEdeoVgTbTU1F6thMusZY8AjfpR8LYg+m3bIyszltMMZxy0Fxb9q5sLE5z5nZt9ISvOKn1EzkhH3iqQp4DKHaeAib49OARf6iX/CzwdZY+ShIHHEmu8Cd5nZ45KWqzTTHpFGuh6Blhr4hNH/RHE/8IUHglaOGe/aNuf3khwm4NKifrVfD9XxwVFppBX0FyprREk9t/13gceC5l/IxBjwpKTvzSypattQ1sUNMv+BITrEVZAGvVcFPVjR/zhzQxltdXodm2ZagWln0p71IDAD/LIVPa66NXMo/Tw6Xg7aka+aWSevP7MRPpJl+qPAtzmtl4T/PvZNeBieAa71rlUW8do59DwP7Ac+BB6uLF3W6SOZlF/0ee0K6Dhj4/S/AgJcB/xV4U+fbZaP9Fwo3QpYkbQsaUnSir9zArgT+LVk/QfM7MHtmkfCsUD4ZTt/TG9bRoJu4tPAHSVTlyo0NrKEeLmZXePOrJww2woSZ8frriuAvWa2J+oo5433JX29XRNiFWTJ8h2noVVGa5vtNdLA5H8G7gH+CZp1297Zs8j3HrDbpX+TpPksuv1vuih+eErp/0ujMVHnTTso4TwZ/wKpmLzPy5yEyAAAAABJRU5ErkJggg==" type="image/png"/>

ï»¿<style id="style-base" type="text/css">

/* Presets */

* {
  font-variant-ligatures: common-ligatures;
  -webkit-font-variant-ligatures: common-ligatures;
  
  -webkit-font-feature-settings: "liga", "dlig";
  -o-font-feature-settings: "liga", "dlig";
  -ms-font-feature-settings: "liga", "dlig";
  -moz-font-feature-settings: "liga=1, dlig=1";
  -moz-font-feature-settings: "liga", "dlig";
  font-feature-settings: "liga", "dlig";
  
  -webkit-box-sizing: border-box;
  -o-box-sizing: border-box;
  -ms-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;

  -webkit-font-smoothing: antialiased;
  -o-font-smoothing: antialiased;
  -ms-font-smoothing: antialiased;
  -moz-font-smoothing: antialiased;
  font-smoothing: antialiased;

  -webkit-text-rendering: geometricPrecision;
  -o-text-rendering: geometricPrecision;
  -ms-text-rendering: geometricPrecision;
  -moz-text-rendering: geometricPrecision;
  text-rendering: geometricPrecision;

  -webkit-text-size-adjust: 100%;      
  -o-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  -moz-text-size-adjust: 100%;
  text-size-adjust: 100%;

  -webkit-transform-style: preserve-3d !important;
  -o-transform-style: preserve-3d !important;
  -ms-transform-style: preserve-3d !important;
  -moz-transform-style: preserve-3d !important;
  transform-style: preserve-3d !important;

  -webkit-transform: matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  -o-transform-style: matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  -ms-transform-style: matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  -moz-transform-style: matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  transform-style: matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  
  -webkit-perspective: 1000px;
  -o-perspective: 1000px;
  -ms-perspective: 1000px;
  -moz-perspective: 1000px;
  perspective: 1000px;
}

img {
  -ms-interpolation-mode: bicubic;
  image-rendering: optimizeQuality;
  vertical-align: middle;
}

svg {
  margin: 0px;
  padding: 0px;
  height: 100%;
  width: 100%;
  vertical-align: top;
}

svg:not(:root) {
  overflow: hidden;
}

.clearfix {
  clear: both;
  content: "";
  display: block;
  outline: 0px;
  margin: 0px;
  border: 0px;
  padding: 0px;
  height: 0px;
  width: 0px;
  opacity: 0;
  visibility: hidden;
  overflow: hidden;
  *zoom: 1;
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
}

.circle {
  -webkit-border-radius: 50%;
  -o-border-radius: 50%;
  -ms-border-radius: 50%;
  -moz-border-radius: 50%;
  border-radius: 50%;
}

.text-indent {
  text-indent: 1.5vw;
}

.faded {
  opacity: 0.25 !important;
  -webkit-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -moz-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -ms-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -o-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
}

.invisible {
  opacity: 0 !important;
  -webkit-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -moz-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -ms-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -o-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
}

.cubicInOut {
  -webkit-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -moz-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -ms-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -o-transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  transition: opacity 300ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  
  -webkit-transition: background, color 500ms, 500ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -moz-transition: background, color 500ms, 500ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -ms-transition: background, color 500ms, 500ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  -o-transition: background, color 500ms, 500ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
  transition: background, color 500ms, 500ms cubic-bezier(0.645, 0.045, 0.355, 1.000);
}

/* Page Elements */

#head {
  display: none !important;
}

#html, #body, #main {
  position: relative !important;
  margin: 0px !important;
  border: 0px !important;
  padding: 0px !important;
  outline: 0px !important;
  height: 100% !important;
  width: 100% !important;
  overflow: hidden;
}

#main {
  position: relative;
  margin-top: 0px;
  margin-right: 0px;
}

.button-base {
  display: block;
  margin: 0px;
  border: 0px;
  padding: 0px 1vw;
  height: 4vw;
  width: auto;
  font-family: Verdana, Georgia, serif;
  font-size: 2vw;
  line-height: 4vw;
  text-align: center;
  vertical-align: middle;
  color: #fff;
  background-color: #041a2f; /* #041a2f; Sanderson Indigo */
  cursor: pointer;
}

.button-base:hover {
  background-color: #3b5998; /* #3b5998; Facebook Blue */
}

#button-next {
  z-index: 1000000;
  position: absolute;
  top: 0px;
  right: 0px;
}

#modal-overlay,
.modal-overlay {
  z-index: 1000000;
  display: block;
  position: fixed;
  top: 0px;
  left: 0px;
  height: 100vw;
  width: 100vw;
  background-color: rgba(0, 0, 0, 0.75);
  cursor: pointer;
}

#modal-overlay: hover,
.modal-overlay: hover {

}

#modal-box,
.modal-box {
  display: block;
  float: left;
  margin: 1vw 0px 0px 1vw;
  border: 1px solid rgba(0, 0, 0, 0.25);
  background-color: rgba(255, 255, 255, 0.5);
}

#modal-box: hover,
.modal-box: hover {

}

#modal-text,
.modal-text {
  display: block;
  float: left;
  padding: 0.75vw 1vw 1vw 1vw;
  font-family: Verdana, Georgia, serif;
  font-size: 0.75vw;
  line-height: 1.5;
  text-align: left;
  vertical-align: baseline;
  color: #000;
}

#storage {
  display: none !important;
  margin-top: -500% !important;
  margin-left: -500% !important;
}

</style>
  
<script>

//General XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var cleanElementHTML = function cleanElementHTML(o) {
  o.normalize();
  var imax = o.childNodes.length;
  for (var i = 0; i < imax; i++) {
    var p = o.childNodes[i];
    if (p && p.nodeType == 3 && !/\S/.test(p.nodeValue)) {
      o.removeChild(p);
      i--;
    }
    if (p && p.nodeType == 1) {
      cleanElementHTML(p);
    }
  }
  return o;
};

(function() {
  var methodsList = ["assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeStamp", "trace", "warn"];
  var length = methodsList.length;
  var console = (window.console = window.console || {});
  while (length--) {
    var eachMethod = methodsList[length];
    if (!console[eachMethod]) {
      console[eachMethod] = function() {};
    }
  }
}());

(function() {
  window.performance = window.performance || {};
  window.performance.now = (function() {
  return window.performance.now       ||
         window.performance.mozNow    ||
         window.performance.msNow     ||
         window.performance.oNow      ||
         window.performance.webkitNow ||
         function() { return new Date().getTime(); };
  })();
}());

(function() {
  if (!window.requestAnimationFrame && !window.cancelAnimationFrame) {
    var vendors = ["moz", "ms", "o", "webkit"];
    var imax = vendors.length;
    for (var i = 0; i < imax; i++) {
      var a = vendors[i] + "RequestAnimationFrame";
      window.requestAnimationFrame = window[a];
      var b = vendors[i] + "CancelAnimationFrame";
      var c = vendors[i] + "CancelRequestAnimationFrame";
      window.cancelAnimationFrame = window[b] || window[c];
    }
  }
  
  var tick = 1000 / 60;
  var total = window.performance.now();
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(f, data) {
      var td = window.performance.now();
      var wait = Math.max(0, ((total + tick) - td));
      var frameID = window.setTimeout(function() { f(data); }, wait);
      total = total + tick;
      return frameID;
    };
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(frameID) {
      clearTimeout(frameID);
	  for (var i = 1; i < 10000; i++) {
	    clearTimeout(i);
	  }
    };
  }
}());

(function () {
  function CustomEvent(event, parameters) {
    parameters = parameters || { bubbles: false, cancelable: true, detail: undefined };
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent(event, parameters.bubbles, parameters.cancelable, parameters.detail);
    return e;
   };
  CustomEvent.prototype = window.CustomEvent.prototype;
  window.CustomEvent = CustomEvent;
})();

//AJAX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var ajax = function(type, url, sendData) {
  if (window.XMLHttpRequest) { var http = new XMLHttpRequest(); } 
  if (window.ActiveXObject) { try { var http = new ActiveXObject("Msxml2.XMLHTTP"); } catch (e) { try { var http = new ActiveXObject("Microsoft.XMLHTTP"); } catch (e) { } } }
  if (!http) { return false; }
  http.open(type, url, true);
  http.setRequestHeader("content-type", "application/x-www-form-urlencoded");
  http.onreadystatechange = function() {
    console.log("http: " + type + "   url: " + url + "   ready: " + http.readyState + "   status: " + http.status);
	if (http.readyState === 4 && http.status === 200) {
      console.log(http.responseText);
	}
  }
  http.send(sendData);
  return false;
};

var uploadJSON = function (data, fileName, hrefLocation) {
  data = JSON.stringify(data, null, "   ");
  var encodedData = window.btoa(unescape(window.encodeURIComponent(data))) || window.btoa(unescape(window.encodeURI(data)));
  var sendData = "dataFileName=" + fileName + "&dataJSON=" + encodedData;
  ajax("POST", "dl/uploadJSON.php", sendData);
  document.getElementById(hrefLocation).setAttribute("href", "dl/downloadFile.php?fileName=" + fileName);
  return data;
};

//Strings XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var filterJSON = function(key, value) {
  if (stringContains(key, "target") === true) {
	var result = "(circular reference)";
	if (value.id) { result += " id: #" + value.id; }
	if (value.className) { result += " className: " + value.className; }
    return result;
  }
  if (value instanceof Function) {
    return value.name || "Function";
  }
  return value;
};

var camelToHyphen = function(camel) {
  camel = "" + camel;
  return camel.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};

var hyphenToCamel = function(hyphen) {
  hyphen = "" + hyphen;
  return hyphen.replace(/-([a-z])/gi, function($1) { return $1.toUpperCase(); } ).replace(/-/gi, "");
};

var stringContains = function(a, b) {
  a = "" + a;
  b = "" + b;
  var regex = new RegExp(b, "gi");
  return regex.test(a);
};

var stringStartsWith = function(a, b) {
  a = "" + a;
  b = "" + b;
  return a.substring(0, b.length) === b;
};

var trimStringEnds = function(a, start, end) {
  a = "" + a;
  if (!start) { var start = " "; } else { start = "" + start; }
  if (a.length < start.length) { start = start.substring(0, a.length); }
  if (!end) { var end = " "; } else { end = "" + end; }
  if (a.length < end.length) { end = end.substring(0, a.length); }  
  if (a.length === 1) { if (a === start || a === end) { var empty = ""; return empty; } else { return a; } }
  if (a.substring(0, start.length) === start) { var x = start.length; } else { var x = 0; }
  if (a.substring(a.length - end.length, a.length) === end) { var y = a.length - end.length; } else { var y = a.length; }
  return a.substring(x, y);
};

//Numbers XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var PHI = function() {
  return (1 + Math.sqrt(5)) / 2;
};

var noopReturnArgumentZero = function(a) {
  return a;
};

var randomPositiveNegative = function(a) {
  var range = Math.random() - Math.random();
  if (a) { return range * parseFloat(a); }
  return range;
};

var randomBoundedRange = function(min, max) {
  var min = parseFloat(min);
  var max = parseFloat(max);
  var result = min + randomPositiveNegative(max);
  if (Math.abs(result) < min) { result = min; }
  return result;
};

var filteredParseFloat = function(a) {
  a = parseFloat(a);
  if (a === 0.0) { return a; }
  if (!a ||
      a === false ||
	  typeof a === "undefined" ||
	  a === null ||
	  a === Infinity ||
	  a === -Infinity ||
	  a !== a) {
    return false;
  } else {
    return a;
  }
};
  
var lerp = function(start, end, time) {
  return start + (time * (end - start));
};

var lerpDelta = function(start, delta, time) {
  return start + (time * delta);
};

var perlinBias = function(t, bias) {
  //x^(log(B)/log(0.5))
  if (!bias) { var bias = Math.log(bias) / Math.log(0.5); }
  return Math.max(0, Math.pow(t, bias));
};

var toHex = function(a) {
  var hex = a.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
};

var exponentialCurve = function(base, exponent) {
  base = 1 * base;
  exponent = 1 * exponent;
  return Math.pow(base, exponent);
};

//Arrays XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var getFloat32Array = function(n) {
  if (n) { var a = parseInt(a, 10); }
  if (a && a > 0) {
    if (typeof Float32Array !== "undefined") { var result = new Float32Array(a); } else { var result = new Array(a); }
    for (var i = 0; i < a; i++) { result[i] = 0.0; }
	return result;
  }
  return new Array();
};

Array.prototype.remove = function(from, to) {  
  var rest = this.slice((to || from) + 1 || this.length);  
  this.length = from < 0 ? this.length + from : from;  
  return this.push.apply(this, rest);  
};

var setDataArray = function(target, label, a) {
  if (target instanceof HTMLElement) {
    var storage = target;
  } 
  if (!storage) {
    var storage = document.getElementById("" + target);
  } 
  if (!storage) {
    var storage = document.createElement("div");
	storage.id = "" + target;
	storage.style.visibility = "hidden";
	storage.style.position = "absolute";
	storage.style.top = "-1000px";
	storage.style.left = "-1000px";
	storage.style.height = "0px";
	storage.style.width = "0px";
	document.getElementById("body").appendChild(storage);
  }
  var item;
  for (var i = 0; i < a.length; i++) {
    item = "data-" + label + "-" + i;
    storage.setAttribute(item, "" + a[i]);
  }
  return false;
};

var getDataArray = function(id, label, processing) {
  if (document.getElementById("" + id)) {
    var storage = document.getElementById("" + id);
  } else {
    var storage = id;
  }
  if (!label) { var label = storage.id; }
  var result = new Array();
  var a;
  for (var i = 0; i < 1000; i++) {
    a = storage.getAttribute("data-" + label + "-" + i);
	if (!a) { if (result.length > 0) { break; } else { return false; } }
	if (processing) { 
	  if (processing === "float" || processing === "float32") { a = parseFloat(a); }
	  if (processing === "integer" || processing === "int") { a = parseInt(a); }
      if (processing instanceof Function) { a = processing(a); }
	}
	result[i] = a;
  }
  if (processing && processing === "float32") {
    var rl = result.length;
    var f32 = getFloat32Array(rl);
	var rj;
	for (var j = 0; j < rl; j++) { rj = result[j]; f32[j] = rj; }
	return f32;
  } else {
    return result;
  }
};

var cullUniqueValues = function(a) {
  var result = new Array();
  counter = 0;
  var b = 0;
  var j = 0;
  var length = a.length;
  for (var i = 1; i < length; i++) {
    j = i - 1;
    if (a[j] && a[j] !== a[i]) {
	  b = a[j];
	  result[counter] = b;
	  counter++;
	}
  }
  if (a[length - 1] !== a[length - 2]) {
    b = a[length - 1];
    a[counter] = b;
  }
  return result;
};

var arrayToCSV = function(a, separator) {
  var length = a.length;
  if (length < 2) { return "" + a; }
  var result = "";
  var last = length - 1;
  if (!separator) { var separator = ","; }
  for (var i = 0; i < length; i++) {
    if (i < last) {
      result += "" + a[i] + separator;
	} else {
	  result += "" + a[i];
	}
  };
  return result;
};

var stringToFloat32Array = function(a, separator) {
  if (!separator) { var separator = ","; }
  a.split(separator);
  var result = getFloat32Array(a.length);
  for (var i = 0; i < a.length; i++) {
    result[i] = parseFloat(a[i]);
  };
  return result;
};

//Classes XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var hasClass = function(o, a) {
  if (!o) { return false; }
  a = "" + a;
  return stringContains(o.className, a);
};

var addClass = function(o, a) {
  if (!o) { return false; }
  a = "" + a;
  if (stringContains(o.className, a) === false) {
    if (o.className.length === 0 || o.className === " ") {
	  o.className = a;
	} else {
	  o.className = o.className + " " + a;
	}
  }
  return o.className;
};

var removeClass = function(o, a) {
  if (!o) { return false; }
  a = "" + a;
  if (stringContains(o.className, a) === false) {
    return o.className;
  }
  var culled = "";
  var updated = "";
  var list = o.className.split(" ");
  for (var i = 0; i < list.length; i++) {
    culled = trimStringEnds(list[i], "  ", "  ");
	culled = trimStringEnds(list[i], " ", " ");
    if (culled !== a) {
      updated += "" + list[i] + " ";
	}
  }
  o.className = updated.substring(0, updated.length - 1);
  return o.className;
};

var toggleClass = function(o, a, b) {
  if (!o) { return false; }
  a = "" + a;
  b = "" + b;
  var testA = hasClass(o, a);
  var testB = hasClass(o, b);
  if (testA === true && testB === false) {
    removeClass(o, a);
	addClass(o, b);
  }
  if (testA === false && testB === true) {
    removeClass(o, b);
	addClass(o, a);
  }
  if (testA === true && testB === true) {
    removeClass(o, b);
  }
  if (testA === false && testB === false) {
  	addClass(o, a);
  }
  return o.className;
};
  
//Scaling XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var setHTMLRem = function() {
  var oneVW = document.getElementById("html").clientWidth;
  oneVW = (oneVW * 0.000001) * 10000;
  document.getElementById("html").style.fontSize = "" + oneVW + "px !important";
  return false;
};

var vw = function(a) {
  if (!a) { var a = 1; } else { a = 1 * a; }
  var oneVW = document.getElementById("html").clientWidth;
  return a * ((oneVW * 0.000001) * 10000);
};

var vh = function(a) {
  if (!a) { var a = 1; } else { a = 1 * a; }
  var oneVH = document.getElementById("html").clientHeight;
  return a * ((oneVH * 0.000001) * 10000);
};

var scaleViewport = function(a) {
  if (!a) { var a = 1; } else { a = 1 * a; }
  return a * (document.getElementById("html").clientWidth / window.screen.width);
};

var scaleLinear = function(maxMeasure, maxScreen, minMeasure, minScreen) {
  var viewport = document.getElementById("html").clientWidth;
  return maxMeasure - ( (maxScreen - viewport) * (minMeasure / (maxScreen - minScreen)) ); 
};

//Colors XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var generateColor = function(n) {

  var red = Math.round(Math.random() * 255);
  var green = Math.round(Math.random() * 255);
  var blue = Math.round(Math.random() * 255);
  var alpha = Math.round(Math.random() * 100000) / 100000;
  
  if (!n || typeof n === "undefined") { return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")"; }
  
  var q = "";
  var m = {};
  for (var p in n) {
	q = p.substring(0, 1);
	  
	if (q === "r" || q === "g" || q === "b" || q === "R" || q === "G" || q === "B") {
	  
	  m[q] = parseInt(n[p], 10);
		
	  if ((q === "r" || q === "g" || q === "b") &&
		 ((typeof m[q] === "undefined" || m[q] === null || m[q] !== n[q] || m[q] === Infinity || m[q] === -Infinity) ||
		m[q] < 0)) { m[q] = 0; }
		
	  if ((q === "R" || q === "G" || q === "B") &&
		 ((typeof m[q] === "undefined" || m[q] === null || m[q] !== n[q] || m[q] === Infinity || m[q] === -Infinity) ||
		m[q] > 255)) { m[q] = 255; }	
	}
	  
	if (q === "a" || q === "A") {
	    
      m[q] = parseFloat(n[p]);
	  
	  if ((q === "a") &&
		 ((typeof m[q] === "undefined" || m[q] === null || m[q] !== n[q] || m[q] === Infinity || m[q] === -Infinity) ||
		m[q] < 0.0)) { m[q] = 0.0; }

	  if ((q === "A") &&
		 ((typeof m[q] === "undefined" || m[q] === null || m[q] !== n[q] || m[q] === Infinity || m[q] === -Infinity) ||
		m[q] > 1.0)) { m[q] = 1.0; }		   
	}
	  
	if (q === "type") { m[q] = n[p]; }
	  
	delete n;
  }
  
  if (m.r && red < m.r) { red = m.r; }
  if (m.R && red > m.R) { red = m.R; }
  if (m.g && red < m.g) { green = m.g; }
  if (m.G && red > m.G) { green = m.G; }
  if (m.b && red < m.b) { blue = m.b; }
  if (m.B && red > m.B) { blue = m.B; }
  if (m.a && red < m.a) { alpha = m.a; }
  if (m.A && red > m.A) { alpha = m.A; }	
  
  if (m.type && typeof m.type !== "undefined" && m.value && typeof m.value !== "undefined") {
    m.type = ("" + m.type).toLowerCase();
	m.value = ("" + m.value).toLowerCase();
    if (m.value === "string" || m.value === "css") {
	  if (m.type === "rgba") { return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")"; }
	  if (m.type === "rgb") { return "rgba(" + red + ", " + green + ", " + blue + ")"; }
	  if (m.type === "hex") { return "#" + toHex(red) + toHex(green) + toHex(blue); }
	}
    if (m.value === "array") {
	  if (m.type === "rgba") { return [red, green, blue, alpha]; }
	  if (m.type === "rgb") { return [red, green, blue]; }
	  if (m.type === "hex") { return [toHex(red), toHex(green), toHex(blue)]; }
	}
    if (m.value === "json" || m.value === "object") {
	  if (m.type === "rgba") { return { r: red, g: green, b: blue, a: alpha }; }
	  if (m.type === "rgb") { return { r: red, g: green, b: blue }; }
	  if (m.type === "hex") { return { r: toHex(red), g: toHex(green), b: toHex(blue) }; }
	}  
  }
  
  return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")";
};

var getRandomRGB = function() {
  var red = Math.round(Math.random() * 255);
  var blue = Math.round(Math.random() * 255);
  var green = Math.round(Math.random() * 255);
  return "rgb(" + red + ", " + green + ", " + blue + ")";
};

var getRandomHex = function() {
  var red = Math.round(Math.random() * 255);
  var blue = Math.round(Math.random() * 255);
  var green = Math.round(Math.random() * 255);
  return "#" + toHex(red) + toHex(green) + toHex(blue);
};

var splitHexChannels = function(hex) {

  hex = "" + hex;
  
  if (hex.substring(0, 1) === "#" && hex.length < 6) {
    var rr = hex.substring(1, 2) + hex.substring(1, 2);
	var gg = hex.substring(2, 3) + hex.substring(2, 3);
	var bb = hex.substring(3, 4) + hex.substring(3, 4);
  }

  if (hex.substring(0, 1) === "#" && hex.length > 6) {
    var rr = hex.substring(1, 3);
	var gg = hex.substring(3, 5);
	var bb = hex.substring(5, 7);
  }
 
  if (hex.substring(0, 1) !== "#" && hex.length > 5) {
    var rr = hex.substring(0, 2);
	var gg = hex.substring(2, 4);
	var bb = hex.substring(4, 6);
  }
  
  return {
    r: parseInt(rr, 16),
    g: parseInt(gg, 16),
    b: parseInt(bb, 16)
  };
};

function bitwiseToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
};

var getColorType = function(a) {
  if (a.substring(0, 4) === "rgba") {
    var type = "rgba";
  } else if (a.substring(0, 3) === "rgb" && a.substring(3, 4) !== "a") {
    var type = "rgb";
  } else if (a.substring(0, 1) === "#" && a.length > 3) {
    var type = "hex";
  } else {
    var type = undefined;
  }
  return type;
};

var parseColor = function(color, format) {

  color = ("" + color).toLowerCase();
  
  if (color.substring(0, 4) === "rgba") {
    this.list = color.split(",");
    this.listZero = this.list[0].substring(5, this.list[0].length);
    this.R = parseFloat(this.listZero);
	if (typeof this.R === "undefined" || this.R === null || this.R !== this.R || this.R === Infinity || this.R === -Infinity) { return false; }
	this.R = Math.max(Math.min(this.R, 255), 0);
	
    this.G = parseFloat(this.list[1]);
	if (typeof this.G === "undefined" || this.G === null || this.G !== this.G || this.G === Infinity || this.G === -Infinity) { return false; }
	this.G = Math.max(Math.min(this.G, 255), 0);
	
    this.B = parseFloat(this.list[2]);
	if (typeof this.B === "undefined" || this.B === null || this.B !== this.B || this.B === Infinity || this.B === -Infinity) { return false; }
	this.B = Math.max(Math.min(this.B, 255), 0);
	
	this.A = parseFloat(this.list[3]);
	if (typeof this.A === "undefined" || this.A === null || this.A !== this.A || this.A === Infinity || this.A === -Infinity) { return false; }
	this.A = Math.max(Math.min(this.A, 1.0), 0.0);
	
  } else if (color.substring(0, 3) === "rgb" && color.substring(0, 4) !== "rgba") {
  
    this.list = color.split(",");
    this.listZero = this.list[0].substring(4, this.list[0].length);
    this.R = parseFloat(this.listZero);
	if (typeof this.R === "undefined" || this.R === null || this.R !== this.R || this.R === Infinity || this.R === -Infinity) { return false; }
	this.R = Math.max(Math.min(this.R, 255), 0);
	
    this.G = parseFloat(this.list[1]);
	if (typeof this.G === "undefined" || this.G === null || this.G !== this.G || this.G === Infinity || this.G === -Infinity) { return false; }
	this.G = Math.max(Math.min(this.G, 255), 0);
	
    this.B = parseFloat(this.list[2]);
	if (typeof this.B === "undefined" || this.B === null || this.B !== this.B || this.B === Infinity || this.B === -Infinity) { return false; }
	this.B = Math.max(Math.min(this.B, 255), 0);
	
	this.A = 1.0;
	
  } else if (color.substring(0, 1) === "#" && color.length > 3) {
	
	this.CL = color.length;
	color = color.substring(1, this.CL);
	
    if (this.CL < 5) {
      this.R = color.substring(0, 1);
	  this.R = this.R + this.R;
	  this.G = color.substring(1, 2);
	  this.G = this.G + this.G;
	  this.B = color.substring(2, 3);
	  this.B = this.B + this.B;
    } else {
      this.R = color.substring(0, 2);
	  this.G = color.substring(2, 4);
	  this.B = color.substring(4, 6);
    }
  
    this.R = parseInt(this.R, 16);
	if (typeof this.R === "undefined" || this.R === null || this.R !== this.R || this.R === Infinity || this.R === -Infinity) { return false; }
	this.R = Math.max(Math.min(this.R, 255), 0);
	
    this.G = parseInt(this.G, 16);
	if (typeof this.G === "undefined" || this.G === null || this.G !== this.G || this.G === Infinity || this.G === -Infinity) { return false; }
	this.G = Math.max(Math.min(this.G, 255), 0);
	
    this.B = parseInt(this.B, 16);
	if (typeof this.B === "undefined" || this.B === null || this.B !== this.B || this.B === Infinity || this.B === -Infinity) { return false; }
	this.B = Math.max(Math.min(this.B, 255), 0);
	
	this.A = 1.0;

  } else {
    return false;
  }

  if (!format || typeof format === "undefined") {
    return [this.R, this.G, this.B, this.A];
  } else {
    format = ("" + format).toLowerCase();
  }
  if (format.substring(0, 5) === "array") {
    return [this.R, this.G, this.B, this.A];
  }
  if (format.substring(0, 4) === "json" || format.substring(0, 6) === "object") {
    return { r: this.R, g: this.G, b: this.B, a: this.A };
  }
  if (format.substring(0, 4) === "numbered") {
    return { "0": this.R, "1": this.G, "2": this.B, "3": this.A };
  }
  
  return [this.R, this.G, this.B, this.A];
};

//Style XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var vendorPrefix = function(a, p) {
  var htmlComputedStyle = window.getComputedStyle(document.documentElement, null);
  htmlComputedStyle = Array.prototype.slice.call(htmlComputedStyle).join("");
  
  if (!a || (a && (a === null || a === "all"))) {
    var a = ["ah", "apple", "atsc", "hp", "khtml", "moz", "ms", "mso", "prince", "rim", "ro", "wap", "webkit", "tc"];
  }
  
  if (!p) {
    var p = "";
  } else {
    p = p.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  
  if (a instanceof Array) {
    var hyphen, parse;
    for (var i = 0; i < a.length; i++) {
      hyphen = "-" + a[i] + "-" + p;
	  parse = (htmlComputedStyle.match(new RegExp(hyphen, "gi")) || (htmlComputedStyle.OLink === "" && ["", "o"]))[1];
      if (parse) { 
	    return { hyphen: hyphen, camel: a[i].substring(0, 1).toUpperCase() + a[i].substring(1, a[i].length) };
	  }
    }
    return false;
	
  } else {
    var parse = (htmlComputedStyle.match(new RegExp("-" + a + "-" + p, "gi")) || (htmlComputedStyle.OLink === "" && ["", "o"]))[1];
    if (parse) { 
	  return { hyphen: hyphen, camel: a.substring(0, 1).toUpperCase() + a.substring(1, a.length) };
	} else {
	  return false;
	}
  }
  
  return false;
};

var parseStyleValue = function(o, prop, A, B, C, D) {
  if (!o) { return false; }
  prop = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  var vendor = vendorPrefix(null, prop);
  if (vendor === false) { vendor = prop; } else { vendor = vendor.hyphen; }
  var a;
  
  if (A && o[A]) {
    var tree = o[A];
	if (B && o[B]) { tree = tree[B]; }
	if (C && o[C]) { tree = tree[C]; }
	if (D && o[D]) { tree = tree[D]; }
    a = tree[prop] || tree[vendor];
    if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") { return { value: a, property: vendor }; }
  }
  
  a = o.getAttribute("data-" + prop) || o.getAttribute("data-" + vendor);
  if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") { return { value: a, property: vendor }; }
  
  a = o.style[prop] || o.style[vendor];
  if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") { return { value: a, property: vendor }; }
 
  var bcr = o.getBoundingClientRect();
  a = bcr[prop];
  if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") { return { value: "" + a + "px", property: vendor }; }
  
  a = window.getComputedStyle(o, null).getPropertyValue(prop) ||
      window.getComputedStyle(o, null).getPropertyValue(vendor);
  if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") { return { value: a, property: vendor }; }
 
  var regex;
  a = ("" + o.style["filter"]).toLowerCase() ||
      ("" + window.getComputedStyle(o, null).getPropertyValue("filter")).toLowerCase();
  if (a && a !== undefined && a !== null && a === a && a !== "" && a !== "none" && a !== "auto") {
    regex = new RegExp(prop, "gi");
	if (regex.test(a)) { return { value: a, property: vendor }; }
    regex = new RegExp(vendor, "gi");
	if (regex.test(a)) { return { value: a, property: vendor }; }
  }
  
  return false;
};

var parseCSSUnitFromString = function(a) {
  a = "" + a;
  var b = "";
  var list = ["deg", "rad", "px", "rem", "em", "vh", "vw", "%", "rgba", "rgb", "#"];
  for (var i = 0; i < list.length; i++) {
    b = list[i];
    var regex = new RegExp(b, "gi");
	if (regex.test(a) === true) { return b; }  
  }
  return "";
};

var cssUnitConversions = function(o) {
  if (!o) { return false; }
  var html = document.getElementById("html");
  var result = {
    px: 1,
	vh: (html.clientHeight * 0.000001) * 10000,
	vw: (html.clientWidth * 0.000001) * 10000
  };
  
  var REM = parseFloat(html.style.fontSize);
  if (!REM) { REM = parseFloat(window.getComputedStyle(html, null).getPropertyValue("font-size")); }
  if (!REM) { REM = 16; }
  result.rem = REM;
  
  var p = o.parentNode;
  if (!p) {
    result.em = REM; return result;
  }
  var EM = parseFloat(window.getComputedStyle(p, null).getPropertyValue("font-size"));
  if (!EM) {
    var pp = p.parentNode;
	EM = parseFloat(window.getComputedStyle(pp, null).getPropertyValue("font-size"));
  }
  if (!EM) {
    var ppp = pp.parentNode;
    EM = parseFloat(window.getComputedStyle(ppp, null).getPropertyValue("font-size"));
  }
  if (!EM) { EM = REM; }
  result.em = EM;
  
  return result;
};

var parseObjectStyle = function(o, prop) {
  if (!o || !prop) { return false; }
  var result = {};
  
  var oPSV = parseStyleValue(o, prop);
  result.value = oPSV.value;
  result.property = oPSV.property;
  result.unit = parseCSSUnitFromString(result.value);
  
  if (result.unit === "rgba" || result.unit === "rgb" || result.unit === "#") {
    result.value = parseColor(result.value);
	return result;
  }

  if (result.unit === "deg") {
    result.deg = parseFloat(result.value);
	result.rad = result.deg * (Math.PI / 180);
    return result;
  }
  
  if (result.unit === "rad") {
    result.rad = parseFloat(result.value);
	result.deg = result.rad * (180 / Math.PI);
    return result;
  }
 
  var parentPSV = parseStyleValue(o.parentNode, prop); 
  result.parentValue = parentPSV.value;
  result.parentUnit = parseCSSUnitFromString(result.parentValue);
  
  var parsed = parseFloat(result.value);
  
  if (result.unit === "%" && result.parentUnit === "%") {
    result.percent = parsed;
    return result;
  }
  
  var measures = cssUnitConversions(o);
  
  if (result.unit === "%") {
    result.percent = parsed;
	result.px = (parsed / 100) * (parseFloat(result.parentValue) * measures[result.parentUnit]);
  } else {
    result.px = parsed * measures[result.unit];
    result.percent = (result.px / (parseFloat(result.parentValue) * measures[result.parentUnit])) * 100;
  }
  
  var list = ["rem", "em", "vh", "vw", ""];
  var a;
  for (var i = 0; i < list.length; i++) {  
    a = list[i];
	if (result.unit === a) {
	  result[a] = parsed;
	} else {
	  result[a] = (parsed * parseFloat(measures[result.unit])) / parseFloat(measures[a]);
	}
  }
  
  return result;
};

var inlineStyleVendor = function(o, prop, value, unit) {
  o.style["-webkit-" + prop] = value + "" + (unit || "");
  o.style["-o-" + prop] = value + "" + (unit || "");
  o.style["-ms-" + prop] = value + "" + (unit || "");
  o.style["-moz-" + prop] = value + "" + (unit || "");
  return false;
};

var getStyleSheetRuleBlock = function(selector) {
  selector = "" + selector;
  var imax = document.styleSheets.length;
  for (var i = 0; i < imax; i++) {
    var jmax = document.styleSheets[i].cssRules.length;
    for (var j = 0; j < jmax; j++) {
      var block = document.styleSheets[i].cssRules[j];
      if (block.selectorText === selector || 
	      block.selectorText === "#" + selector || 
	      block.selectorText === "." + selector) {
		var result = {};
		for (var rule in block.style) {
		  if (block.style[rule] !== "" &&
		      block.style[rule] !== null &&
			  block.style[rule] !== undefined &&
			  typeof block.style[rule] !== "function" &&
			  !parseInt(rule, 10) &&
			  rule !== 0 &&
			  rule !== "0" &&
			  rule !== "cssText" &&
			  rule !== "length" &&
			  rule !== "parentRule") {
		    result[rule] = block.style[rule];
		  }
		} //for (var rule in block.style)
      } //if (block.selectorText...
    } //j-cycle
  } //i-cycle
  console.log(result);
  return result;
};

var getOffsetTLHW = function(o) {
  var offset = {
    top: o.offsetTop,
	left: o.offsetLeft,
	height: o.offsetHeight,
	width: o.offsetWidth
  };
  console.log(offset);
  return offset;
};

var getBCR = function(o) {
  var bcr = o.getBoundingClientRect();
  console.log(bcr);
  return bcr;
};

var getRandomTop = function(o) {
  return Math.round(Math.random() * (vh(100) - o.offsetHeight));
};
  
var getRandomLeft = function(o) {
  return Math.round(Math.random() * (vw(100) - o.offsetWidth));
};

//Matrix XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/mat4.js

var identityMatrix = function(out) {
  if (!out) { var out = []; }
  out[0] = 1.0;  out[1] = 0.0;  out[2] = 0.0;  out[3] = 0.0;
  out[4] = 0.0;  out[5] = 1.0;  out[6] = 0.0;  out[7] = 0.0;
  out[8] = 0.0;  out[9] = 0.0;  out[10] = 1.0; out[11] = 0.0;
  out[12] = 0.0; out[13] = 0.0; out[14] = 0.0; out[15] = 1.0;
  return out;
};

var adjointMatrix = function(a, out) {
  var a00, a01, a02, a03,
      a10, a11, a12, a13,
	  a20, a21, a22, a23,
	  a30, a31, a32, a33;
  a00 = a[0];  a01 = a[1];  a02 = a[2];  a03 = a[3];
  a10 = a[4];  a11 = a[5];  a12 = a[6];  a13 = a[7];
  a20 = a[8];  a21 = a[9];  a22 = a[10]; a23 = a[11];
  a30 = a[12]; a31 = a[13]; a32 = a[14]; a33 = a[15];
  if (!out) { var out = []; }
  if (!a) { var a = identityMatrix(); }
  out[0] =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1] = 0.0 - (a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3] = 0.0 - (a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = 0.0 - (a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6] = 0.0 - (a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8] =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9] = 0.0 - (a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = 0.0 - (a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = 0.0 - (a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = 0.0 - (a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
};

var multiplyMatrix = function (a, b, out) {
  if (!out) { var out = []; }
  var a00, a01, a02, a03,
      a10, a11, a12, a13,
	  a20, a21, a22, a23,
	  a30, a31, a32, a33;
  a00 = a[0];  a01 = a[1];  a02 = a[2];  a03 = a[3];
  a10 = a[4];  a11 = a[5];  a12 = a[6];  a13 = a[7];
  a20 = a[8];  a21 = a[9];  a22 = a[10]; a23 = a[11];
  a30 = a[12]; a31 = a[13]; a32 = a[14]; a33 = a[15];
  var b0 = b[0]; var b1 = b[1]; var b2 = b[2]; var b3 = b[3];
  out[0] = (b0 * a00) + (b1 * a10) + (b2 * a20) + (b3 * a30);
  out[1] = (b0 * a01) + (b1 * a11) + (b2 * a21) + (b3 * a31);
  out[2] = (b0 * a02) + (b1 * a12) + (b2 * a22) + (b3 * a32);
  out[3] = (b0 * a03) + (b1 * a13) + (b2 * a23) + (b3 * a33);
  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = (b0 * a00) + (b1 * a10) + (b2 * a20) + (b3 * a30);
  out[5] = (b0 * a01) + (b1 * a11) + (b2 * a21) + (b3 * a31);
  out[6] = (b0 * a02) + (b1 * a12) + (b2 * a22) + (b3 * a32);
  out[7] = (b0 * a03) + (b1 * a13) + (b2 * a23) + (b3 * a33);
  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = (b0 * a00) + (b1 * a10) + (b2 * a20) + (b3 * a30);
  out[9] = (b0 * a01) + (b1 * a11) + (b2 * a21) + (b3 * a31);
  out[10] = (b0 * a02) + (b1 * a12) + (b2 * a22) + (b3 * a32);
  out[11] = (b0 * a03) + (b1 * a13) + (b2 * a23) + (b3 * a33);
  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = (b0 * a00) + (b1 * a10) + (b2 * a20) + (b3 * a30);
  out[13] = (b0 * a01) + (b1 * a11) + (b2 * a21) + (b3 * a31);
  out[14] = (b0 * a02) + (b1 * a12) + (b2 * a22) + (b3 * a32);
  out[15] = (b0 * a03) + (b1 * a13) + (b2 * a23) + (b3 * a33);
  return out;
};

var frustumMatrix = function(params, out) {
  if (!params || params.length < 6) {
    return false;
  } else {
    var T, B, TB, R, L, RL, N, F, NF, N2;
    T = 1.0 * params[0];
    B = 1.0 * params[1];
    TB = 1.0 / (T - B);
    R = 1.0 * params[2];
    L = 1.0 * params[3];
    RL = 1.0 / (R - L);
    N = 1.0 * params[4];
	F = 1.0 * params[5];
	NF = 1.0 / (N - F);
	N2 = N * 2;
  }  
  if (!out) { var out = []; }
  out[0] = N2 * RL;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = N2 * TB;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = (R + L) * RL;
  out[9] = (T + B) * TB;
  out[10] = (N + F) * NF;
  out[11] = 0.0 - 1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = ((N * F) * 2.0) * NF;
  out[15] = 1.0;
  return out;
};

var perspectiveMatrix = function (params, out) {
  //http://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/
  if (!out) { var out = []; }
  if (!params) {
    var focus, viewport, foa, near, far, FN, out10, out11;
    focus = 1.0 / Math.tan(115);
    viewport = document.getElementById("html");
    foa = focus / (viewport.clientWidth / viewport.clientHeight);
    near = 0.0;
	far = 20.0;
	FN = far - near;
	if (FN === 0) { FN = 0.0000000000001; }
	out10 = (far + near) / FN;
	out11 = (2.0 * far * near) / FN;
  }
  out[0] = foa; // || (1.0 * params[0]);
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = focus; // || (1.0 * params[1]);
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = 0.0;
  out[9] = 0.0;
  out[10] = out10; // || (1.0 * params[2]);
  out[11] = out11; // || (1.0 * params[3]);
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = 0.0 - (1.0 / FN);
  out[15] = 1.0;
  return out;
};

var translateMatrix = function(axis, a, out) { 
  if (!out) { var out = a; }
  if (!a) { var a = identityMatrix(); }
  var x, y, z, a30, a31, a32, a33;
  x = (1.0 * axis[0]) || 0.0;
  y = (1.0 * axis[1]) || 0.0;
  z = (1.0 * axis[2]) || 0.0;
  a30 = a[12];
  a31 = a[13];
  a32 = a[14];
  a33 = a[15];
  if (a === out) {
    out[12] = (a[0] * x) + (a[4] * y) + (a[8] * z) + a30;
    out[13] = (a[1] * x) + (a[5] * y) + (a[9] * z) + a31;
    out[14] = (a[2] * x) + (a[6] * y) + (a[10] * z) + a32;
    out[15] = (a[3] * x) + (a[7] * y) + (a[11] * z) + a33;
  } else {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
	out[1] = a01;
	out[2] = a02;
	out[3] = a03;
    out[4] = a10;
	out[5] = a11;
	out[6] = a12;
	out[7] = a13;
    out[8] = a20;
	out[9] = a21;
	out[10] = a22;
	out[11] = a23;
    out[12] = (a00 * x) + (a10 * y) + (a20 * z) + a30;
    out[13] = (a01 * x) + (a11 * y) + (a21 * z) + a31;
    out[14] = (a02 * x) + (a12 * y) + (a22 * z) + a32;
    out[15] = (a03 * x) + (a13 * y) + (a23 * z) + a33;
  }
  return out;
};

var skewMatrix = function(axis, a, out) {
  //1     tanX  0     0
  //tanY  1     0     0
  //0     0     1     0
  //0     0     0     1
  if (!out) { var out = a; }
  if (!a) { var a = identityMatrix(); }
  var x = Math.tan(1.0 * axis[0]);
  if (x !== x) { x = 0.0; }
  var y = Math.tan(1.0 * axis[1]);
  if (y !== y) { y = 0.0; }
  if (a === out) {
    out[1] = x;
    out[4] = y;
  } else {
    var a00, a02, a03, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33;
    a00 = a[0];
	//a01 replaced by x
    a02 = a[2];
    a03 = a[3];
	//a10 replaced by y
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    out[0] = a00;
	out[1] = x;
	out[2] = a02;
	out[3] = a03;
    out[4] = y;
	out[5] = a11;
	out[6] = a12;
	out[7] = a13;
    out[8] = a20;
	out[9] = a21;
	out[10] = a22;
	out[11] = a23;  
    out[12] = a30;
    out[13] = a31;
    out[14] = a32;
    out[15] = a33;
  }
  return out;
};

var scaleMatrix = function(axis, a, out) {
  if (!out) { var out = a; }
  if (!a) { var a = identityMatrix(); }
  var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  out[0] = a00 * (1.0 + axis[0]);
  out[1] = a01;
  out[2] = a02;
  out[3] = a03;
  out[4] = a10;
  out[5] = a11 * (1.0 + axis[1]);
  out[6] = a12;
  out[7] = a13;
  out[8] = a20;
  out[9] = a21;
  out[10] = a22 * (1.0 + axis[2]);
  out[11] = a23;
  if (a !== out) {
    var a30, a31, a32, a33;
    a30 = a[12]; out[12] = a30;
    a31 = a[13]; out[13] = a31;
    a32 = a[14]; out[14] = a32;
    a33 = a[15]; out[15] = a33;
  }
  return out;
};

var rotateMatrix = function(axis, a, out) {
  if (!out) { var out = a; }
  if (!a) { var a = identityMatrix(); }
  var x = rotateAxis([1.0, 0.0, 0.0, axis[0]], a, out);
  var y = rotateAxis([0.0, 1.0, 0.0, axis[1]], x, out);
  return rotateAxis([0.0, 0.0, 1.0, axis[2]], y, out);
};

var rotateAxis = function(axis, a, out) {
  if (!out) { var out = a; }
  if (!a) { var a = identityMatrix(); }
  var x, y, z, xt, yt, zt, xs, ys, zs, s, c, t, length, radians, 
      a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23,
      b00, b01, b02,      b10, b11, b12,      b20, b21, b22;
  x = (1.0 * axis[0]) || 0.0;
  y = (1.0 * axis[1]) || 0.0;
  z = (1.0 * axis[2]) || 0.0;
  if (x === 0.0 && y === 0.0 && z === 0.0) { return a; }
  length = Math.sqrt((x * x) + (y * y) + (z * z));
  if (Math.abs(length) < 0.0000000000001) { return a; }
  length = 1.0 / length;
  x *= length;
  y *= length;
  z *= length;
  radians = ((1.0 * axis[3]) * (Math.PI / 180)) || 0.0;
  s = Math.sin(radians);
  c = Math.cos(radians);
  t = 1.0 - c;
  xt = x * t; xs = x * s;
  yt = y * t; ys = y * s;
  zt = z * t; zs = z * s;
  a00 = a[0]; b00 = (x * xt) + c;
  a01 = a[1]; b01 = (x * yt) + zs;
  a02 = a[2]; b02 = (x * zt) - ys;
  a03 = a[3]; 
  a10 = a[4]; b10 = (y * xt) - zs;
  a11 = a[5]; b11 = (y * yt) + c;
  a12 = a[6]; b12 = (y * zt) + xs;
  a13 = a[7]; 
  a20 = a[8]; b20 = (z * xt) + ys;
  a21 = a[9]; b21 = (z * yt) - xs;
  a22 = a[10]; b22 = (z * zt) + c;
  a23 = a[11]; 
  out[0] = (a00 * b00) + (a10 * b01) + (a20 * b02);
  out[1] = (a01 * b00) + (a11 * b01) + (a21 * b02);
  out[2] = (a02 * b00) + (a12 * b01) + (a22 * b02);
  out[3] = (a03 * b00) + (a13 * b01) + (a23 * b02);
  out[4] = (a00 * b10) + (a10 * b11) + (a20 * b12);
  out[5] = (a01 * b10) + (a11 * b11) + (a21 * b12);
  out[6] = (a02 * b10) + (a12 * b11) + (a22 * b12);
  out[7] = (a03 * b10) + (a13 * b11) + (a23 * b12);
  out[8] = (a00 * b20) + (a10 * b21) + (a20 * b22);
  out[9] = (a01 * b20) + (a11 * b21) + (a21 * b22);
  out[10] = (a02 * b20) + (a12 * b21) + (a22 * b22);
  out[11] = (a03 * b20) + (a13 * b21) + (a23 * b22);
  if (a !== out) {
    var a30, a31, a32, a33;
    a30 = a[12]; out[12] = a30;
    a31 = a[13]; out[13] = a31;
    a32 = a[14]; out[14] = a32;
    a33 = a[15]; out[15] = a33;
  }
  return out;
};

var cameraMatrix = function(eye, up, center, out) {
  //xaxis.x          yaxis.x          zaxis.x          0
  //xaxis.y          yaxis.y          zaxis.y          0
  //xaxis.z          yaxis.z          zaxis.z          0
  //dot(xaxis,-eye)  dot(yaxis,-eye)  dot(zaxis,-eye)  1
  if (!out) { var out = identityMatrix(); }
  var eyeX, eyeY, eyeZ, upX, upY, upZ, centerX, centerY, centerZ, length, z0, z1, z2, x0, x1, x2, y0, y1, y2;
  
  if (!eye) {
    eyeX = 0.0;
    eyeY = 0.0;
    eyeZ = 0.0;
  } else {
    eyeX = (1.0 * eye[0]) || 0.0;
    eyeY = (1.0 * eye[1]) || 0.0;
    eyeZ = (1.0 * eye[2]) || 0.0;
  }
  
  if (!up) {
    upX = 0.0;
	upY = 1.0;
	upZ = 0.0;
  } else {
    upX = (1.0 * up[0]) || 0.0;
    upY = (1.0 * up[1]) || 1.0;
    upZ = (1.0 * up[2]) || 0.0;
  }
  
  if (!center) {
    centerX = 0.0;
    centerY = 0.0;
    centerZ = 0.0;
  } else {
    centerX = (1.0 * center[0]) || 0.0;
    centerY = (1.0 * center[1]) || 0.0;
    centerZ = (1.0 * center[2]) || 0.0;
  }
  
  z0 = eyeX - centerX;
  z1 = eyeY - centerY;
  z2 = eyeZ - centerZ;
  if (Math.abs(z0) < 0.0000000000001 &&
      Math.abs(z1) < 0.0000000000001 &&
      Math.abs(z2) < 0.0000000000001) {
	return out;
  }  
  
  length = 1.0 / Math.sqrt((z0 * z0) + (z1 * z1) + (z2 * z2));
  z0 *= length;
  z1 *= length;
  z2 *= length;
  
  x0 = (upY * z2) - (upZ * z1);
  x1 = (upZ * z0) - (upX * z2);
  x2 = (upX * z1) - (upY * z0);
  length = Math.sqrt((x0 * x0) + (x1 * x1) + (x2 * x2));
  if (!length || length !== length || length === 0) {
    x0 = 0.0;
    x1 = 0.0;
    x2 = 0.0;
  } else {
    length = 1.0 / length;
    x0 *= length;
    x1 *= length;
    x2 *= length;
  }

  y0 = (z1 * x2) - (z2 * x1);
  y1 = (z2 * x0) - (z0 * x2);
  y2 = (z0 * x1) - (z1 * x0);
  length = Math.sqrt((y0 * y0) + (y1 * y1) + (y2 * y2));
  if (!length || length !== length || length === 0) {
    y0 = 0.0;
    y1 = 0.0;
    y2 = 0.0;
  } else {
    length = 1.0 / length;
    y0 *= length;
    y1 *= length;
    y2 *= length;
  }
  
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  //out[3] = 0.0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  //out[7] = 0.0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  //out[11] = 0.0;
  out[12] = 0.0 - ((x0 * eyeX) + (x1 * eyeY) + (x2 * eyeZ));
  out[13] = 0.0 - ((y0 * eyeX) + (y1 * eyeY) + (y2 * eyeZ));
  out[14] = 0.0 - ((z0 * eyeX) + (z1 * eyeY) + (z2 * eyeZ));
  //out[15] = 1.0;
  return out;
};

var inlineStyleMatrix = function(o, a) {
  var base = "matrix3d("
  + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " 
  + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", "
  + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", ";
  var standard = base + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  var fireFox = base + a[12] + "px, " + a[13] + "px, " + a[14] + ", " + a[15] + ")";
  o.style["-webkit-transform"] = standard;
  o.style["-ms-transform"] = standard;
  o.style["-moz-transform"] = fireFox;
  o.style["-o-transform"] = standard;
  o.style["transform"] = standard;
/* 
  //ie9
  o.style["transform"] = "matrix(" + a[0] + ", " + a[1] + ", " + a[4] + ", " + a[5] + ", " + a[12] + ", " + a[13] + ")";
  var progid = ""
  + "progid:DXImageTransform.Microsoft.Matrix(" 
  + "M11=\"" + a[0] + ";\" "
  + "M12=\"" + a[1] + ";\" "
  + "M21=\"" + a[4] + ";\" "
  + "M22=\"" + a[5] + ";\" " 
  + "Dx=\"" + a[12] + ";\" "
  + "Dy=\"" + a[13] + ";\" "
  + "SizingMethod=\"auto expand;\" "
  + "FilterType=\"nearest neighbor;\")";
  //ie8
  o.style["-ms-filter"] = progid;
  //ie6-7
  o.style["filter"] = progid;
*/
  return false;
};

//Splines XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  
var cubicBÃ©zierParametric = function(t, points) {
  var oneMinusT, f0, f1, f2, f3;
  oneMinusT = 1.0 - t;
  f0 = oneMinusT * oneMinusT * oneMinusT * points[0];
  f1 = 3.0 * oneMinusT * oneMinusT * t * points[1];
  f2 = 3.0 * oneMinusT * t * t * points[2];
  f3 = t * t * t * points[3];
  return f0 + f1 + f2 + f3;
};

var cubicBÃ©zierNewtonRaphson = function(t, points) {
  var A = (1.0 * points[3]) - (3.0 * points[2]) + (3.0 * points[1]) - (1.0 * points[0]);    
  var B = (3.0 * points[2]) - (6.0 * points[1]) + (3.0 * points[0]);
  var C = (3.0 * points[1]) - (3.0 * points[0]);
  //var D = (1.0 * points[0]);
  return (A * t * t * t) + (B * t * t) + (C * t) + (1.0 * points[0]);
};

var cubicBÃ©zierCatmullRom = function(t, points) {
  var t2, t3, f0, f1, f2, f3;
  t2 = t * t;
  t3 = t * t * t;
  f0 = ((0.0 - 0.5) * t3) + t2 - (0.5 * t);
  f0 = f0 * points[0];
  f1 =  (1.5 * t3) - (2.5 * t2) + 1.0;
  f1 = f1 * points[1];
  f2 = ((0.0 - 1.5) * t3) + (2.0 * t2) + (0.5 * t);
  f2 = f2 * points[2];
  f3 =  (0.5 * t3) - (0.5 * t2);
  f3 = f3 * points[3];
  return f0 + f1 + f2 + f3;
};

var splineCatmullRom = function(t, points) {
  var knots, span, f3, f2, f1, p3, p2, p1, p0;
  knots = points.length - 3;
  t = Math.min(Math.max(t, 0.0), 1.0) * knots;
  span = Math.floor(t);
  if (span >= knots) { span = knots; }
  t -= span;
  p0 = points[span];
  p1 = points[span + 1];
  p2 = points[span + 2];
  p3 = points[span + 3];
  f3 = ((0.0 - 0.5) * p0) + (1.5 * p1) - (1.5 * p2) + (0.5 * p3);
  f2 = p0 - (2.5 * p1) + (2 * p2) - (0.5 * p3);
  f1 = ((0.0 - 0.5) * p0) + (0.5 * p2);
  //var f0 = p1;
  return (((((f3 * t) + f2) * t) + f1) * t) + p1;
};

var randomSplinePoints = function(n, first, last) {
  if (!n || n < 4) { var n = 4 + Math.round(Math.random() * 8); }
  var n1 = n - 1;
  var result = [];
  if (first && last) {
    result[0] = parseFloat(first);
    for (var i = 1; i < n1; i++) { result[i] = randomPositiveNegative(1); };
    result[n1] = parseFloat(last);  
  } else {
    result[0] = 0.0;
    for (var i = 1; i < n1; i++) { result[i] = randomPositiveNegative(1); };
    result[n1] = 1.0;
  }
  return result;
};

var getEasingParameters = function(a) {

  var list = new Array();
  list[0] = "Cubic BÃ©zier: Parametric";
  list[1] = "Cubic BÃ©zier: Newton-Raphson";
  list[2] = "Cubic BÃ©zier: Catmull-Rom";
  list[3] = "Catmull-Rom: N Knots";
  list[4] = "Exponential Curve";
  list[5] = "Perlin Bias";
  list[6] = "Time Ratio";
  
  if (!a) {
    var type = "Catmull-Rom: N Knots"; //list[Math.floor(Math.random() * list.length)];
  } else {
    var type = list[a] || "Catmull-Rom: N Knots";
  }
  var result = {};
  
  if (type === "Cubic BÃ©zier: Parametric") {
    result.type = "Cubic BÃ©zier: Parametric";
	var points = randomSplinePoints(4);
	result.controls = [];
	result.controls[0] = points[0];
	result.controls[1] = points[1];
	result.controls[2] = points[2];
	result.controls[3] = points[3];
	result.formula = cubicBÃ©zierParametric;
  }

  if (type === "Cubic BÃ©zier: Newton-Raphson") {
    result.type = "Cubic BÃ©zier: Newton-Raphson";
	var points = randomSplinePoints(4);
	result.controls = [];
	result.controls[0] = points[0];
	result.controls[1] = points[1];
	result.controls[2] = points[2];
	result.controls[3] = points[3];
	result.formula = cubicBÃ©zierNewtonRaphson;
  }

  if (type === "Cubic BÃ©zier: Catmull-Rom") {
    result.type = "Cubic BÃ©zier: Catmull-Rom";
	result.controls = [];
	result.controls[0] = randomPositiveNegative(10);
	result.controls[1] = 0.0;
	result.controls[2] = 1.0;
	result.controls[3] = randomPositiveNegative(10);
	result.formula = cubicBÃ©zierCatmullRom;
  }
   
  if (type === "Catmull-Rom: N Knots") {
    result.type = "";
	var mids = randomSplinePoints();
	result.controls = [];
	result.controls[0] = randomPositiveNegative(10);
	for (var i = 0; i < mids.length; i++) { result.controls[i + 1] = mids[i]; }
	result.controls[result.controls.length - 1] = randomPositiveNegative(10);
	result.type = "Catmull-Rom: " + result.controls.length + " Knots";
	result.formula = splineCatmullRom;
  }
  
  if (type === "Exponential Curve") {
    result.type = "Exponential Curve";
    result.controls = 1.0 + (Math.random() * 4.0); 
	result.formula = exponentialCurve;
  }
  
  if (type === "Perlin Bias") {
    result.type = "Perlin Bias";
    result.controls = Math.log(Math.random()) / Math.log(0.5);
	result.formula = perlinBias;
  }
 
  if (type === "Time Ratio") {
    result.type = "Time Ratio";
    result.controls = 1.0;
	result.formula = noopReturnArgumentZero;
  }
  
  return result;
};

//Sloopy Helpers XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	
var parseStringToArray = function(v, quantity) {
  v = "" + v;
  v = v.split(",");
  v[0] = v[0].substring(9, v[0].length);
  var result = [];
  for (var i = 0; i < quantity; i++) {
    result[i] = parseFloat(v[i]) || 0.0;
  }
  return result;
};

var convertMatrix2DTo3D = function(a) {
  var b = [];
  b[0] = parseFloat(a[0]) || 1.0;
  b[1] = parseFloat(a[1]) || 0.0;
  b[2] = 0.0;
  b[3] = 0.0;
  b[4] = parseFloat(a[2]) || 0.0;
  b[5] = parseFloat(a[3]) || 1.0;
  b[6] = 0.0;
  b[7] = 0.0;
  b[8] = 0.0;
  b[9] = 0.0;
  b[10] = 1.0;
  b[11] = 0.0;
  b[12] = parseFloat(a[4]) || 0.0;
  b[13] = parseFloat(a[5]) || 0.0;
  b[14] = 0.0;
  b[15] = 1.0;
  return b;
};

var convertMatrix3DTo2D = function(a) {
  var b = [];
  b[0] = parseFloat(a[0]) || 1.0;
  b[1] = parseFloat(a[1]) || 0.0;
  b[2] = parseFloat(a[4]) || 0.0;
  b[3] = parseFloat(a[5]) || 1.0;
  b[4] = parseFloat(a[12]) || 0.0;
  b[5] = parseFloat(a[13]) || 0.0;
  return b;
};

var parseComputedMultiple = function(v, storage) {
  if (!storage) { storage = {}; }
  v = "" + v;
  v = v.split(",");
  var prop = parsePropertyName(v[0]);
  
  var values = [];
  values[0] = parseNumberFromString(v[0]);
  values[0] = parseFloat(values[0]) || 0.0;
  for (var i = 1; i < v.length; i++) {
    values[i] = parseFloat(v[i]) || 0.0;
  }
  storage[prop] = values;
  
  var units = [];
  result[0] = parseFloat(v0) || 0.0;
  for (var i = 0; i < v.length; i++) {
    units[i] = parsePropertyUnit(v[i]) || "";
  }
  storage[prop + "-unit"] = units; 
  return storage;
};

var parseComputedSingleton = function(v, storage) {
  if (!storage) { storage = {}; }
  v = "" + v;
  var prop = parsePropertyName(v);
  var value = parseNumberFromString(v);
  value = parseFloat(value) || 0.0;
  storage[prop] = value;
  storage[prop + "-unit"] = parsePropertyUnit(v) || "";
  return storage;
};

var parsePropertyName = function(s) {
  s = "" + s;
  var prop = "";
  var parsed;
  for (var i = 0; i < s.length; i++) {
    parsed = parseFloat(s[i]);
    if (!parsed || parsed === undefined || parsed === null || parsed !== parsed) {
	  if (s[i] !== " " && s[i] !== "(") { prop += s[i]; }
	} else { break; }
  }
  var pL = prop.length;
  var xyz = prop.substring(pL - 1, pL).toLowerCase();
  if (xyz === "x" || xyz === "y" || xyz === "z") {
    prop = prop.substring(0, pL - 1).toLowerCase() + xyz.toUpperCase();
  }
  var threeD = prop.substring(pL - 2, pL).toLowerCase();
  if (threeD === "3d") {
    prop = prop.substring(0, pL - 2).toLowerCase() + "3d";
  }
  return prop;
};

var parseNumberFromString = function(s) {
  s = "" + s;
  var parsed;
  for (var i = 0; i < s.length; i++) {
    parsed = parseFloat(s[i]);
    if (s[i] !== "." && 
	   (!parsed || parsed === undefined || parsed === null || parsed !== parsed)) { s[i] = ""; }
  }
  return parseFloat(s);
};

var parsePrefix = function(p) {
  p = cleanString(p);
  p = p.toLowerCase();
  if (p.substring(0, 3) === "-o-" ||
     (p.substring(0, 1) === "o" && p.substring(0, 7) !== "opacity" && p.substring(0, 7) !== "outline")) { return "-o-"; }
  if (p.substring(0, 2) === "ms" || p.substring(0, 4) === "-ms-") { return "-ms-"; }
  if (p.substring(0, 3) === "moz" || p.substring(0, 5) === "-moz-") { return "-moz-"; }
  if (p.substring(0, 6) === "webkit" || p.substring(0, 8) === "-webkit-") { return "-webkit-"; }
  if (p.substring(0, 1) === "#") { return "#"; }
  if (p.substring(0, 3) === "rgb" && p.substring(0, 4) !== "rgba") { return "rgb"; }
  if (p.substring(0, 4) === "rgba") { return "rgba"; }
  return "";
};

var cleanString = function(s) {
  s = "" + s;
  s.replace("(", "", "gi");
  s.replace(")", "", "gi");
  s.replace("[", "", "gi");
  s.replace("]", "", "gi");
  s.replace(",", "", "gi");
  s.replace(";", "", "gi");
  s.replace(" ", "", "gi");
  s.replace("  ", "", "gi");
  s.replace("   ", "", "gi");
  return s;
};

var parsePropertyUnit = function(v) {
  v = cleanString(v);
  v = v.toLowerCase();
  var vL = v.length;
  var v1 = vL - 1;
  var v2 = vL - 2;
  var v3 = vL - 3;
  if (v.substring(v1, vL) === "%") { return "%"; }
  if (v.substring(v1, vL) === "s" && v.substring(v2, vL) !== "ms") { return "s"; }
  if (v.substring(v2, vL) === "em") { return "em"; }
  if (v.substring(v2, vL) === "ms") { return "ms"; }
  if (v.substring(v2, vL) === "px") { return "px"; }
  if (v.substring(v2, vL) === "vw") { return "vw"; }
  if (v.substring(v2, vL) === "vh") { return "vh"; }
  if (v.substring(v3, vL) === "deg") { return "deg"; }
  if (v.substring(v3, vL) === "rad") { return "rad"; }
  if (v.substring(v3, vL) === "rem") { return "rem"; }
  return "";
};

//Sloopy XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

  window.sloopy = function() {};
  
  window.sloopy.runCatmullRom = function(t, points) {
    //var knots, span, f3, f2, f1, /*f0,*/ p3, p2, p1, p0;
    this.knots = points.length - 3;
    t = Math.min(Math.max(t, 0.0), 1.0) * this.knots;
    this.span = Math.floor(t);
    if (this.span > this.knots || this.span === this.knots) { this.span = this.knots; }
    t -= this.span;
    this.p0 = points[this.span];
    this.p1 = points[this.span + 1];
    this.p2 = points[this.span + 2];
    this.p3 = points[this.span + 3];
    //this.f0 = this.p1;
	this.f1 = ((0.0 - 0.5) * this.p0) + (0.5 * this.p2);
	this.f2 = this.p0 - (2.5 * this.p1) + (2 * this.p2) - (0.5 * this.p3);
	this.f3 = ((0.0 - 0.5) * this.p0) + (1.5 * this.p1) - (1.5 * this.p2) + (0.5 * this.p3);
    return (((((this.f3 * t) + this.f2) * t) + this.f1) * t) + this.p1;
  };
  
  var randomFloatSign = function() {
    if (Math.random() > 0.5) { return 1.0; } else { return (0.0 - 1.0); }
  };
  
  var validateNumber = function(a) {
    a = parseFloat(a);
	if (a === 0.0) { return true; }
    if (a === a &&
	    typeof a !== "undefined" &&
		a !== undefined && 
		a !== null &&
		a !== Infinity &&
		a !== -Infinity) { return true; }
	return false;
  };
  
  window.sloopy.catmullRomKnots = function(n) {
    var c = [];

	if (n.knots && typeof n.knots !== "undefined" && parseInt(n.knots, 10) > 5) {
	  var L = parseInt(n.knots, 10) - 4;
	} else {
	  var L = 2 + Math.round(Math.random() * 10);
	}
	
	c[0] = Math.random() * randomFloatSign();
    c[1] = 0.0;
	for (var i = 0; i < L; i++) {
	  c.push(Math.random() * randomFloatSign());
	} 
	c[L + 2] = 1.0;
    c[L + 3] = Math.random() * randomFloatSign();
	
	var CL = c.length;
	
	if (n.range && typeof n.range !== "undefined") {
      var range = parseFloat(n.range);
	  if (validateNumber(range)) {
	    for (var i = 0; i < CL; i++) { 
		  c[i] *= range * Math.random();
		}
	  }
	} 
	
	var last = Math.abs(c[L + 2]);
	for (var i = 0; i < CL; i++) {
	  c[i] = c[i] / last;
	}
	
    if (typeof n.reset === "undefined" || n.reset === false) {
	  c[L + 2] = 1.0;
	} else if (typeof n.reset !== "undefined" && n.reset === true) {
	  c[L + 2] = 0.0;
	} else {
	  var pr = parseFloat(n.reset); 
	  if (validateNumber(pr)) { c[L + 2] = pr; } else { c[L + 2] = 1.0; }
    }

    return c;
  };

  window.sloopy.linearKnots = function(length) {
    if (!length) { var length = 4; }
    var fill = (1 / length) / (length - 2);
	var c = [];
	c[0] = 0.0;
	for (i = 1; i < (length - 1); i++) {
	  c[i] = fill + (i / length);
	}
	c[length - 1] = 1.0;
    return c;
  };
  
  window.sloopy.parseArrayToFloats = function(a) {
    if (!(a instanceof Array)) { return false; }
	if (a.length === 0) { return false; }
	
	var parsed = [];
	var p = 0.0;
	var total = 0.0;
    for (var i = 0; i < a.length; i++) {
	  p = parseFloat(a[i]);
	  if (typeof p === "undefined" || p === null || p !== p || p === Infinity || p === -Infinity) { 
	    p = 0.0;
	  } else {
	    p = Math.round(p * 100000) / 100000;
	  }
	  parsed[i] = p;
	  total += p;
    }
	if (total === 0.0) { return false; } else { return parsed; }
  };
  
  window.sloopy.setEasingControls = function(source) {
  
    var controls = source.controls;
	
    if (!controls || typeof controls === "undefined") {
	  return window.sloopy.catmullRomKnots(source);
	}
	
    if (controls instanceof Array) {
	  var parsedControls = window.sloopy.parseArrayToFloats(controls);
	  if (parsedControls === false) {
	    return window.sloopy.catmullRomKnots(source);
	  } else {
	    return window.sloopy.normalizeKnots(parsedControls);
	  }
	}
	
	var controlsString = ("" + controls).toLowerCase();
	if (controlsString === "catmull-rom" || controlsString === "cr") {
	  return window.sloopy.catmullRomKnots(source);
	} else if (controlsString === "linear") {
	  return [0.0, Math.random() * randomFloatSign(), Math.random() * randomFloatSign(), 1.0];
	} else {
	  return controls;
	}
	
    return false;
  };
  
  window.sloopy.normalizeKnots = function(a) {
    if (!(a instanceof Array)) { return false; }
	if (a.length === 0) { return false; }
	
	var L = a.length;
	if (a[L - 1] === 1.0) {
      return a;
	} else { 
	  var divisor = a[L - 2];
	}
	
	if (divisor === 1.0) {
	  return a;
	} 
	
	if (divisor === 0.0) {
	  var abs = 0.0;
	  for (var i = 0; i < L; i++) {
	    abs = Math.abs(a[i]);
	    if (abs > divisor) { divisor = abs; }
	  }
	}
	
	for (var i = 0; i < L; i++) {
	  a[i] = a[i] / divisor;
	};
	
    return a;
  };
  
  window.sloopy.setTransformPrefix = function() {
    return vendorPrefix(null, "transform")["hyphen"];
  };

  window.sloopy.setAnimationFolder = function(target) {
    if (!target.animation || typeof target.animation === "undefined") { target.animation = {}; }
	return target;
  };

  window.sloopy.setTargetPosition = function(target) {
	target.style.position = "absolute";
	var bcr = target.getBoundingClientRect();
	target.style.top = parseFloat(bcr.top) + "px";
	target.style.left = parseFloat(bcr.left) + "px";
	return target;
  };
  
  window.sloopy.setMatrix3D = function(target) {
  
    target = window.sloopy.setAnimationFolder(target);
	var TA = target.animation;
	
	if (!TA.transform || typeof TA.transform === "undefined") {
	  TA.transform = vendorPrefix(null, "transform")["hyphen"];
	}

	TA.matrix3d = window.getComputedStyle(target, null).getPropertyValue(TA.transform);
	
	if (TA.matrix3d === "none" || typeof TA.matrix3d === "undefined") { 
	  TA.matrix3d = "matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)";
	}
	
	var mozRGX = new RegExp("moz", "gi");
	if (mozRGX.test(TA.transform) === true) {
      target.style.backgroundClip = "padding-box";
	  target.style["-moz-box-shadow"] = "0px 0px 1px 1px transparent";
      target.style.boxShadow = "0px 0px 1px 1px transparent";
	  target.style.outline = "1px solid transparent";
	}
	
	target.style[TA.transform] = TA.matrix3d;
	
	return target;
  };
  
  window.sloopy.isTransform = function(name) {
  	var transformList = ["rotate", "scale", "skew", "translate"];
	var suffixList = ["-x", "-y", "-z", "3d"];
	for (var i = 0; i < 4; i++) {
	  for (var j = 0; j < 4; j++) {
	    this.assembled = transformList[i] + suffixList[j];
	    this.transformRGX = new RegExp(this.assembled, "gi");
	    if (this.transformRGX.test(name) === true && this.assembled !== "skew3d") {
	      return name.replace(/-([a-z])/gi, function($1) { return $1.toUpperCase(); } ).replace(/-/gi, "");
	    }
	  }
	}
	return false;
  };
  
  window.sloopy.legalStyleValue = function(value) {
    if (parseFloat(value) === 0) { return true; }
	if (typeof value === "undefined" ||
		value === null ||
		value !== value ||
		value === Infinity ||
		value === -Infinity) {
	  return false;
	} else {
	  return true;
	}
  };
  
  window.sloopy.legalStyleName = function(name) {
    name = ("" + name).replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    if (name.substring(0, 3) === "get" ||
		name.substring(0, 3) === "set" ||
	    name.substring(0, 6) === "length" ||
		name.substring(0, 7) === "csstext" ||
		parseInt(name, 10) || 
		parseInt(name, 10) === 0) {
	  return false;
	} else {
	  return name;
	}
  };

  window.sloopy.filterComputed = function(target, n) {
	var CS = window.getComputedStyle(target, null);
	if (n && typeof n !== "undefined") { var list = n; } else { var list = CS; }
	var result = {};
	var checkTransform, CSP, checkCSP;
	for (var p in list) {
	
	  p = window.sloopy.legalStyleName(p);
	  if (!p) { continue; }
	  
	  checkTransform = window.sloopy.isTransform(p);
	  if (checkTransform) {
	    if (typeof target.animation !== "undefined" &&
		    typeof target.animation[p] !== "undefined" && 
		    typeof target.animation[p].end !== "undefined") {
	      var previousTransformValue = target.animation[p].end;
		  var checkPTV = window.sloopy.legalStyleValue(checkPTV);
		  if (!checkPTV) { result[p] = 0.0; }
		  result[p] = previousTransformValue;
	    } else {
	      result[p] = 0.0;
	    }
		continue;
	  }
	  
	  CSP = CS[p];
	  checkCSP = window.sloopy.legalStyleValue(CSP);
	  if (!checkCSP) { continue; }
	  result[p] = CSP;
	}
	
    return result;
  };
  
  window.sloopy.add = function(target, animationParameters) {
  
    window.sloopy.setAnimationFolder(target); //console.log("animationParameters"); console.log(animationParameters);
	
	var added = window.sloopy.filterAdded(animationParameters); //console.log("filterAdded"); console.log(added);
	
	added = window.sloopy.splitAdded(added); //console.log("splitAdded"); console.log(added);
	
	added = window.sloopy.parseStyleFolder(added); //console.log("parseStyleFolder"); console.log(added);
	
    var computed = window.sloopy.filterComputed(target, added); //console.log("filterComputed"); console.log(computed);
	
	computed = window.sloopy.parseStyleFolder(computed); //console.log("parseStyleFolder"); console.log(computed);
	
	target = window.sloopy.parseDelta(target, computed, added); //console.log("parseDelta"); console.log(target.animation);
	
	target = window.sloopy.setTimeRunEase(target); //console.log("setTimeRunEase"); console.log(target.animation);
	
	return false;
  };
  
  window.sloopy.setTimeRunEase = function(target) {
    var TAP;
    for (p in target.animation) {
	
	  TAP = target.animation[p];
	  window.sloopy.setTimers(TAP, TAP);
	  
	  target = window.sloopy.setRunFunction(target);
	  
	  target.animation[p] = window.sloopy.cacheFunction(TAP, TAP, "easing", "runCatmullRom");
	  
	  TAP = target.animation[p];
	  target.animation[p].controls = window.sloopy.setEasingControls(TAP);
	  
	  //TAP = target.animation[p];
	  //window.sloopy.cacheFunction(TAP, TAP, "callback", false);
	  
	  TAP = undefined;
	}
	
    return target;
  };
  
  window.sloopy.setRunFunction = function(target) {
    
	var colorRX = new RegExp("color", "gi");
	var gradientRX = new RegExp("gradient", "gi");
	var linearRX = new RegExp("linear", "gi");
	var radialRX = new RegExp("radial", "gi");
	var TAP, valueType;
	
	for (p in target.animation) {
	
	  TAP = target.animation[p];
	  if (TAP.run &&
	      typeof TAP.run !== "undefined" &&
		  typeof window.sloopy[TAP.run] !== "undefined" &&
		  window.sloopy[TAP.run] instanceof Function) { continue; }
	
	  if (colorRX.test(p) === true) {
	    target.animation[p].run = "runRGBA";
		continue;
	  }

	  if (gradientRX.test(p) === true) {
	    if (linearRX.test(p) === true) { 
		  target.animation[p].run = "runLinearGradient";
	    } else if (radialRX.test(p) === true) { 
		  target.animation[p].run = "runRadialGradient";
		} else {
		  target.animation[p].run = "runRGBA";
		}
		continue;
	  }
	  /*
	  if (p === "border-radius") {
	    target.animation[p].run = "runBorderRadius";
		continue;
	  }
	  */
	  valueType = TAP.delta;
	  
      if (window.sloopy.isTransform(p)) {
	    var PL = p.length;
	    if (p.substring(PL - 2, PL).toLowerCase() === "3d" && valueType instanceof Array) { 
	      target.animation[p].run = "runTransform3d";
		} else {
		  target.animation[p].run = "runTransform";
		}
		continue;
	  } 
	  
	  if (valueType instanceof Array) {
	    target.animation[p].run = "runMultiple";
	  } else {
		target.animation[p].run = "runSingle";
	  }
	  continue;
	  
	} //for (p in target.animation) {}
	
    return target;
  };
  
  window.sloopy.cacheFunction = function(source, targetFolder, label, useDefault) {
  
    label = label.toLowerCase();
	
    if (useDefault && typeof useDefault !== "undefined" && (!targetFolder[label] || typeof targetFolder[label] === "undefined")) {
	  if (useDefault instanceof Function) {
		var caps = "run" + label.substring(0, 1).toUpperCase() + label.substring(1, label.length);
		if (window.sloopy[caps] && 
		    typeof window.sloopy[caps] !== "undefined" &&
		    window.sloopy[caps] instanceof Function) {
		  targetFolder[label] = caps;
		} else {
		  window.sloopy[caps] = useDefault;
		  targetFolder[label] = caps;
		}
	  } else {
		useDefault = "" + useDefault;
		if (window.sloopy[useDefault] && 
		    typeof window.sloopy[useDefault] !== "undefined" &&
		    window.sloopy[useDefault] instanceof Function) { targetFolder[label] = useDefault; }
	  }
	  return targetFolder;
	}
	
	if (source[label] && typeof source[label] !== "undefined" && source[label] instanceof Function) {
	  var cached = source[label];
	} else if (source && typeof source !== "undefined" && source instanceof Function) {
	  var cached = source;
	} else {
	  return targetFolder;
	}
    var id;
	for (var i = 0; i < 1000000; i++) {
	  id = "" + label + "-" + i;
	  if (!window.sloopy[id] ||
		  typeof window.sloopy[id] === "undefined" ||
		  !(window.sloopy[id] instanceof Function) ||
		  window.sloopy[id] === null ||
		  window.sloopy[id] !== window.sloopy[id]) { break; }
	}
	window.sloopy[id] = cached;
    targetFolder[label] = id;
    return targetFolder;
  };
  
  window.sloopy.setTimers = function(source, targetFolder) {
    var duration, cutoff;
  	if (source.duration) {
	  duration = parseFloat(source.duration);
	}
	if (!duration || typeof duration === "undefined" || duration === null || duration !== duration || duration < 1.0 || duration === Infinity || duration === -Infinity) {
	  duration = 8000.0;
	}
    if (source.cutoff) {
	  cutoff = parseFloat(source.cutoff);
	}
	if (!cutoff || typeof cutoff === "undefined" || cutoff === null || cutoff !== cutoff || cutoff < 1.0 || cutoff === Infinity || cutoff === -Infinity) {
	  cutoff = 1000.0 / 62.5;
	}
	
	targetFolder.duration = duration - cutoff;
	targetFolder.loops = 0;
	targetFolder.start = 0.0;
	targetFolder.elapsed = 0.0;
	targetFolder.per = 0.0;
	targetFolder.done = false;
	
	return targetFolder;
  };
  
  window.sloopy.parseDelta = function(target, computed, added) {
  
    window.sloopy.setAnimationFolder(target);
	
  	var copyVariables = function(folder) {
	  var newFolder = {};
	  for (this.sub in folder) {
	    if (this.sub !== "value") {
		  if (folder[this.sub] instanceof Array) {
			this.source = folder[this.sub];
			this.L = this.source.length;
			var temp = [];
		    for (this.j = 0; this.j < this.L; this.j++) {
			  this.copy = this.source[this.j];
			  temp[this.j] = this.copy;
			}
			newFolder[this.sub] = temp;
		  } else {
	        this.copy = folder[this.sub];
	        newFolder[this.sub] = this.copy;
		  }
		}
	  }
	  return newFolder;
	};
	
	var result, a, A, B, AV, BV, L, i, avi, bvi;
	for (a in added) {
	  A = added[a];
	  B = computed[a];
	  if (typeof A === "undefined" || 
	      typeof A.value === "undefined" ||
		  typeof B === "undefined" ||
		  typeof B.value === "undefined") { continue; }
	  result = copyVariables(A);
	  AV = A.value;
	  BV = B.value;
	  if (AV instanceof Array && BV instanceof Array) {
	    result.delta = [];
	    L = AV.length;
		for (i = 0; i < L; i++) {
		  avi = AV[i];
		  bvi = BV[i];
		  result.delta[i] = avi - bvi;
		}
	  }
	  if (AV instanceof Array && !(BV instanceof Array)) {
	    result.delta = [];
	    L = AV.length;
		for (i = 0; i < L; i++) {
		  avi = AV[i];
		  result.delta[i] = avi - B.value;
		}
	  }
	  if (!(AV instanceof Array) && BV instanceof Array) {
	    result.delta = [];
	    L = BV.length;
		for (i = 0; i < L; i++) {
		  bvi = BV[i];
		  result.delta[i] = A.value - bvi;
		}
	  }
	  if (!(AV instanceof Array) && !(BV instanceof Array)) {
	    result.delta = A.value - B.value;
	  }
	  if (typeof A.reset !== "undefined" && A.reset !== false) {
	    result.base = B.value;
		result.end = B.value;
	  } else {
	    result.base = B.value;
		result.end = A.value;	  
	  }
	  target.animation[a] = copyVariables(result);
	  result = undefined;
	} //for (a in added) {}
    return target;
  };
  
  window.sloopy.filterAdded = function(n) {
	var result = {};
	var resultCounter = 0;
	var NP, checkNP, sub, subCounter;
    for (var p in n) {
	  NP = n[p];
	  p = window.sloopy.legalStyleName(p);
	  if (!p) { continue; }
	  checkNP = window.sloopy.legalStyleValue(NP);
	  if (checkNP === false) { continue; }
	  result[p] = NP;
	  resultCounter++;
	}
	if (resultCounter > 0) { return result; } 
	return false;
  };

  window.sloopy.splitAdded = function(n) {
  
  	var copyVariables = function(folder) {
	  var newFolder = {};
	  for (this.sub in folder) {
	    if (typeof this.sub !== "undefined") {
		  if (folder[this.sub] instanceof Array) {
			this.source = folder[this.sub];
			this.L = this.source.length;
			var temp = [];
		    for (this.j = 0; this.j < this.L; this.j++) {
			  this.copy = this.source[this.j];
			  temp[this.j] = this.copy;
			}
			newFolder[this.sub] = temp;
		  } else {
	        this.copy = folder[this.sub];
	        newFolder[this.sub] = this.copy;
		  }
		}
	  }
	  return newFolder;
	};
	
    var directionalSuffixes = ["-top", "-right", "-bottom", "-left"];
	var borderRadiusStrings = ["border-top-right-radius", "border-top-left-radius", "border-bottom-right-radius", "border-bottom-left-radius"];
	var borderRadiusMap = { top: [0, 1], bottom: [2, 3], left: [1, 3], right: [0, 2] };
	  
	var colorRX = new RegExp("color", "gi");
	var rgbRX = new RegExp("rgb", "gi");
	var hexRX = new RegExp("#", "gi");
	  
	var result = {};
	var NQ, q, QL, baseQ, splitValue, splitLength, baseValue, baseValueSub4, baseValueSub5, baseValueSub6, valueTypeSuffix, mapped, i;
	
    for (q in n) {
	  NQ = n[q];
	  
	  if (typeof NQ.to !== "undefined") {
	    baseValue = "" + NQ.to;
	  } else if (typeof NQ.from !== "undefined") {
	    baseValue = "" + NQ.from;
	  } else if (typeof NQ.value !== "undefined") {
	    baseValue = "" + NQ.value;
	  } else {
	    baseValue = "" + NQ;
	  }
	  if (window.sloopy.legalStyleValue(baseValue) === false) { continue; }
	  splitValue = baseValue.split(" ");
	  splitLength = splitValue.length;

	  q = ("" + q).replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
	  QL = q.length;
	  baseQ = (q.split("-")[0]).replace("-", "");
	  
      if (splitLength === 1 || (colorRX.test(q) === true || rgbRX.test(baseValue) === true || hexRX.test(baseValue) === true)) {
	    
		baseValueSub4 = baseValue.substring(0, 4);
		baseValueSub5 = baseValue.substring(0, 5);
		baseValueSub6 = baseValue.substring(0, 6);
		if (colorRX.test(q) === true || rgbRX.test(baseValue) === true || hexRX.test(baseValue) === true) {
		  NQTO = baseValue;
          valueTypeSuffix = "-color";
		} else if (baseValueSub4 === "none" ||
		           baseValueSub5 === "inset" ||
				   baseValueSub5 === "ridge" ||
				   baseValueSub5 === "solid" ||
				   baseValueSub6 === "dashed" ||
				   baseValueSub6 === "dotted" ||
				   baseValueSub6 === "double" ||
				   baseValueSub6 === "groove" ||
				   baseValueSub6 === "hidden" ||
				   baseValueSub6 === "outset") {
		  valueTypeSuffix = "-style";
		} else {
		  valueTypeSuffix = "-width";
		}
		
		if (q === "margin" || q === "padding") { 
		  for (i = 0; i < 4; i++) {
		    mapped = q + directionalSuffixes[i];
			result[mapped] = copyVariables(NQ);
		  }
		  continue;
	    }
		
		if (q === "border") {
		  for (i = 0; i < 4; i++) {
		      mapped = q + directionalSuffixes[i] + valueTypeSuffix;
			  result[mapped] = copyVariables(NQ);
		  }
		  continue;
		}
		/*
		if (q === "border-radius") {
		  console.log(q);
		  for (i = 0; i < 4; i++) {
			mapped = borderRadiusStrings[i];
			result[mapped] = copyVariables(NQ);
		  }
		  continue;
	    }
		*/
		if (baseQ === "border") {
		  for (i = 0; i < 4; i++) {
		    mapped = baseQ + directionalSuffixes[i];
		    if (q === mapped) {
		      mapped = mapped + valueTypeSuffix;
			  result[mapped] = copyVariables(NQ);
			}
		  }
	    }
		
		for (var brm in borderRadiusMap) {
		  if (q === "border-" + brm + "-radius") {
			for (i = 0; i < 2; i++) {
			  mapped = borderRadiusMap[brm];
			  mapped = mapped[i];
			  mapped = borderRadiusStrings[mapped];
			  result[mapped] = copyVariables(NQ);
			}
			continue;
	      }
		}
		
		if (q === "outline") {
		  mapped = q + valueTypeSuffix;
	      result[mapped] = copyVariables(NQ); continue;
		}
		
		result[q] = NQ;
		continue;
		
	  //splitLength > 1
	  } 
	  
	  result[q] = NQ;
	  continue;
	  
	} //for (var q in n) {}

	return result;
  };
  
  window.sloopy.parseStyleFolder = function(folder) {
  
  	var copyVariables = function(folder) {
	  var newFolder = {};
	  for (this.sub in folder) {
	    if (this.sub !== "value") {
		  if (folder[this.sub] instanceof Array) {
			this.source = folder[this.sub];
			this.L = this.source.length;
			var temp = [];
		    for (this.j = 0; this.j < this.L; this.j++) {
			  this.copy = this.source[this.j];
			  temp[this.j] = this.copy;
			}
			newFolder[this.sub] = temp;
		  } else {
	        this.copy = folder[this.sub];
	        newFolder[this.sub] = this.copy;
		  }
		}
	  }
	  return newFolder;
	};
	
	var transform = vendorPrefix(null, "transform")["hyphen"];
	var colorRX = new RegExp("color", "gi");
	var result = {};
	var q, QL, folderQ, baseValue, splitValue, splitLength, i, vi, vi3, viString;
	
    for (q in folder) {
	  QL = q.length;	  
	  folderQ = folder[q];
	  if (typeof folderQ.to !== "undefined") {
	    baseValue = "" + folderQ.to;
	  } else if (typeof folderQ.from !== "undefined") {
	    baseValue = "" + folderQ.from;
	  } else if (typeof folderQ.value !== "undefined") {
	    baseValue = "" + folderQ.value;
	  } else {
	    baseValue = "" + folderQ;
	  }
	  if (window.sloopy.legalStyleValue(baseValue) === false) { continue; }
	  
	  result[q] = copyVariables(folderQ);
	  
	  splitValue = baseValue.split(" ");
	  splitLength = splitValue.length;
	  for (i = 0; i < splitLength; i++) {
	    vi = splitValue[i];
		viString = "" + vi;
		result[q].value = [];
		result[q].unit = [];
		
		if (window.sloopy.isTransform(q)) {
	      if (q.substring(QL - 2, QL) === "3d") { 
		    result[q].value.push(parseFloat(vi));
		  } else { 
		    result[q].value = parseFloat(vi);
		  }
		  if (q.substring(0, 4) === "skew") { result[q].unit = ""; }
		  if (q.substring(0, 5) === "scale" || q.substring(0, 6) === "rotate") { result[q].unit = "deg"; }
	      if (q.substring(0, 9) === "translate") { result[q].unit = "px"; }
		  result[q].property = q.replace(/-([a-z])/gi, function($1) { return $1.toUpperCase(); } ).replace(/-/gi, "");
		  result[q].transform = transform;
		  continue;
		
	    } else if (colorRX.test(q) === true || viString.substring(0, 1) === "#" || viString.substring(0, 3) === "rgb") {
          if (viString.substring(0, 1) === "#") {
		    if (q.substring(QL - 5, QL) === "color") {
              result[q].value = parseColor("" + vi, "array"); break;
			} else {
			  result[q].value.push(parseColor(vi, "array"));
			}
          }
          if (viString.substring(0, 3) === "rgb") {
		    vi3 = splitValue[i + 3];
		    if (typeof vi3 === "undefined") { vi3 = ""; }
			vi = "" + vi + splitValue[i + 1] + splitValue[i + 2] + vi3;
		    if (q.substring(QL - 5, QL) === "color") {
              result[q].value = parseColor("" + vi, "array"); break;
			} else {
			  result[q].value.push(parseColor(vi, "array"));
			}
		  }
		  
		} else {
		  if ((q === "border" || 
		       q === "border-top" || 
			   q === "border-right" || 
			   q === "border-bottom" || 
			   q === "border-left")&& i > 2) { break; }
		  if (q === "outline" && i < 3) { continue; }
		  
		  if (i < 1 && q.substring(q.length - 9, q.length) === "transform") {
		    if (viString.substring(0, 6) === "matrix") { vi = viString.substring(7, vi.length); }
			if (viString.substring(0, 8) === "matrix3d") { vi = viString.substring(9, vi.length); }
		  }
		  
		  vi = parseFloat(splitValue[i]);
		  if (validateNumber(vi)) { 
		    result[q].value.push(vi); 
		  } else { 
		    result[q].value.push(viString); 
		  }
		  
		  if (typeof folderQ.unit !== "undefined") { 
		    if (folderQ.unit instanceof Array && typeof folderQ.unit[i] !== "undefined") { 
			  result[q].unit.push(folderQ.unit[i]);
			} else {
			  result[q].unit = folderQ.unit;
			}
		  } else {
		    result[q].unit = parsePropertyUnit(viString);
		  }
		}
		
	  } //i-cycle
	  
	  if (result[q].value.length === 1) { result[q].value = result[q].value[0]; }
	  if (result[q].value.length === 0) { result[q].value = baseValue; }
	  if (result[q].unit.length === 1) { result[q].unit = result[q].unit[0]; }
	  if (result[q].unit.length === 0) { delete result[q].unit; }
	  if (typeof result[q].property === "undefined") { result[q].property = q; }
	  
	} //for (var q in folder) {}
	
	return result;
  };
  
  window.sloopy.runRadialGradient = function(t, x) {
  
  };
  
  window.sloopy.runLinearGradient = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style[x.property] = "rgba(" + x.end[0] + ", " + x.end[1] + ", " + x.end[2] + ", " + x.end[3] + ")";
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style[x.property] = "rgba("
	  + Math.max(Math.min((x.base[0] + (x.delta[0] * this.ease)), 255), 0) + ", "
	  + Math.max(Math.min((x.base[1] + (x.delta[1] * this.ease)), 255), 0) + ", "
	  + Math.max(Math.min((x.base[2] + (x.delta[2] * this.ease)), 255), 0) + ", "
	  + Math.max(Math.min((x.base[3] + (x.delta[3] * this.ease)), 1.0), 0.0) + ")";
	  return false;
	}
  };
  
  window.sloopy.runRGBA = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style[x.property] = "rgba(" + x.end[0] + ", " + x.end[1] + ", " + x.end[2] + ", " + x.end[3] + ")";
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style[x.property] = "rgba("
	  + parseInt(Math.max(Math.min((x.base[0] + (x.delta[0] * this.ease)), 255), 0), 10) + ", "
	  + parseInt(Math.max(Math.min((x.base[1] + (x.delta[1] * this.ease)), 255), 0), 10) + ", "
	  + parseInt(Math.max(Math.min((x.base[2] + (x.delta[2] * this.ease)), 255), 0), 10) + ", "
	  + Math.max(Math.min((x.base[3] + (x.delta[3] * this.ease)), 1.0), 0.0) + ")";
	  return false;
	}
  };
  
  window.sloopy.runTransform3D = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style[x.transform] += " " + x.property + "(" + x.end[0] + x.unit + ", " + x.end[1] + x.unit + ", " + x.end[2] + x.unit + ")";
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style[x.transform] += " " + x.property + "("
	  + (x.base[0] + (x.delta[0] * this.ease)) + x.unit + ", "
	  + (x.base[1] + (x.delta[1] * this.ease)) + x.unit + ", " 
	  + (x.base[2] + (x.delta[2] * this.ease)) + x.unit + ")";
	  return false;
	}
  };

  window.sloopy.runTransform = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style[x.transform] += " " + x.property + "(" + x.end + x.unit +")";
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style[x.transform] += " " + x.property + "(" + (x.base + (x.delta * this.ease)) + x.unit +")";
	  return false;
	}
  };
 
  window.sloopy.runMultiple = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	this.L = x.delta.length;
	
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  for (this.i = 0; this.i < this.L; this.i++) {
	    t.style[x.property] = (x.end[this.i] || x.end) + (x.unit || x.unit[this.i]);
	  }
	  return true;
	  
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  for (this.i = 0; this.i < this.L; this.i++) {
		if (x.delta[this.i] === 0) { continue; }
	    t.style[x.property] = ((x.base[this.i] || x.base) + ((x.delta[this.i] || x.delta) * this.ease)) + (x.unit || x.unit[this.i]);
	  }
	  return false;
	}
  };
  
  window.sloopy.runBorderRadius = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style.borderRadius = x.end + "%";
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style.borderRadius = (x.base + (x.delta * this.ease)) + "%";
	  return false;
	}
  };
  
  window.sloopy.runSingle = function(t, x) {
    "use strict"
	if (x.done === true) { return true; }
	this.elapsed = window.performance.now() - x.start;
	if (this.elapsed > x.duration) {
      if (x.elapsed < 1.0) {
	    x.done = true;
	    x.elapsed = window.performance.now() - x.start;
	  }
	  t.style[x.property] = "" + x.end + x.unit;
	  return true;
	} else {
	  this.ease = window.sloopy[x.easing]((this.elapsed / x.duration), x.controls);
	  t.style[x.property] = "" + (x.base + (x.delta * this.ease)) + x.unit;
	  return false;
	}
  };
  
  window.sloopy.parseAnimationQueue = function(targets, propertyNames) {
    "use strict"
	
	if (!(targets instanceof Array)) { 
	  var copy = targets;
	  targets = [];
      targets[0] = copy;
      copy = undefined;
	}
	
	if (!(propertyNames instanceof Array)) { 
	  var copy = propertyNames;
	  propertyNames = [];
      propertyNames[0] = copy;
      copy = undefined;
	}
	
  	var i, j, TA, folder, plain, hyphenated;
    
	loopI:
	for (i = 0; i < targets.length; i++) {
	
	  TA = targets[i].animation;
	  if (!TA || TA === false || typeof TA === "undefined" || TA === null || TA !== TA) {
		targets.remove(i);
		if (targets.length === 0) { return false; } else { continue loopI; }
	  } else {
	    TA.queue = {};
		TA.quantity = 0;
      }
	  
	  for (j = 0; j < propertyNames.length; j++) {
	    plain = propertyNames[j];
	    folder = TA[plain];
		if (folder && folder !== false && typeof folder !== "undefined" && folder !== null && folder === folder) {
		  TA.queue[plain] = false;
		  TA.quantity++;
		} else {
		  hyphenated = plain.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
		  folder = TA[hyphenated];
		  if (folder && folder !== false && typeof folder !== "undefined" && folder !== null && folder === folder) {
			TA.queue[hyphenated] = false;
			TA.quantity++;
		  }
		}
	  } //j-cycle
	  
	  if (TA.quantity === 0) { 
	    targets.remove(i); 
		if (targets.length === 0) { return false; } else { continue loopI; }
	  }
	  
	} //i-cycle
	
	return targets;
  };
  
  //target.style[vendorPrefixTransform] = window.getComputedStyle(target, null).getPropertyValue(vendorPrefixTransform); 
  //target.className = "cubicInOut invisible"; targets[i].className = "";
  
  window.sloopy.runAnimationLoop = function(targets, logTimes) {
    "use strict"
	var that = this;
	
	that.targetsQuantity = targets.length;
	that.targetsDone = 0;
	that.VPT = vendorPrefix(null, "transform")["hyphen"];
	
	for (that.i = 0; that.i < that.targetsQuantity; that.i++) {
	  that.target = targets[that.i];
	  that.queue = that.target.animation.queue;
	  for (that.item in that.queue) {
	    if (that.item === "quantity") { continue; }
		that.TA = that.target.animation;
		that.TA = that.TA[that.item];
		that.TA.loops = 0;
	    that.TA.start = window.performance.now();
	  }
	}

    that.loopRecursion = (function loopRecursion() {
	  that.rafID = window.requestAnimationFrame(loopRecursion);

	  if (that.targetsDone === that.targetsQuantity) {
	    window.cancelAnimationFrame(that.rafID);
		if (logTimes && typeof logTimes !== "undefined") { window.sloopy.consoleTimes(targets); }
	    return false;
	  }
	  
      for (that.i = 0; that.i < that.targetsQuantity; that.i++) {

	    that.target = targets[that.i];
		that.TA = that.target.animation;
		if (that.TA.quantity < 1) { continue; }
		that.target.style[that.VPT] = "";
		
	    for (that.item in that.queue) {
		  
		  that.queue = that.TA.queue;
		  that.TAI = that.TA[that.item];
		  if (that.queue[that.item] === true) { continue; }
		  
	      if (window.sloopy[that.TAI.run](that.target, that.TAI) === true) {
		    that.TA.quantity -= 1;
			that.TAI.done = true;
			if (that.queue[that.item] === false) { that.TAI.loops += 1; }
			that.queue[that.item] = true;
		  } else {
		    that.TAI.loops += 1;
		  }
		}
		
		if (that.TA.quantity < 1) {
		  that.targetsDone += 1;
		}
		
	  } //cycle
	
	}());
	
    return false;
  };
  
  window.sloopy.animate = function(targets, propertyNames, logTimes) {
    "use strict"
	if (window.sloopy.parseAnimationQueue(targets, propertyNames) !== false) {
	  if (!logTimes || typeof logTimes === "undefined") { var logTimes = false; }
	  window.sloopy.runAnimationLoop(targets, logTimes);
	}
	targets, propertyNames, logTimes = undefined;
    return false;
  };
  
  window.sloopy.consoleFolders = function(targets, logFolders) {
    "use strict"
    var parseLF = parseInt(logFolders, 10);
    if (!parseLF || typeof parseLF === "undefined" || parseLF === null || parseLF !== parseLF) { 
	  parseLF = targets.length; 
    }
    for (i = 0; i < parseLF; i++) {
	  console.log(targets[i].animation);
    }	
	return false;
  };
  
  window.sloopy.consoleTimes = function(targets) {
    "use strict"
    this.timeSum = 0.0;
    this.folderSum = 0.0;
    this.loopSum = 0.0;
    for (this.i = 0; this.i < targets.length; this.i++) {
	  this.TA = targets[this.i].animation;
      for (this.item in this.TA.queue) {
		this.TAI = this.TA[this.item];
        this.timeSum += this.TAI.elapsed;
        this.loopSum += this.TAI.loops;
		this.TAI.per = this.TAI.elapsed / this.TAI.loops;
		this.folderSum += 1.0;
      }
    }
	console.log(" ");
	console.log("window.sloopy.logTimes()");
	console.log("  targets:  " + targets.length);
	console.log("  elapsed:  " + (this.timeSum / this.folderSum));
	console.log("  loops:    " + (this.loopSum / this.folderSum));
	console.log("  per:      " + (this.timeSum / this.loopSum));
    return false;
  };

  window.sloopy.save = function(target) {
    var fileName = "loop.json." + (Math.round(Math.random() * 1000000) / 1000000) + ".txt";
    uploadJSON(target.animation, fileName, "href-download");
    return false;
  };
	
var testSloopySetup = function(a) {
  if (!a) { var a = Math.random() * 100; a = 1 + Math.round(a); }
  var body = document.getElementById("body");
  var main = document.getElementById("main");
  main.className = "cubicInOut invisible";
  body.removeChild(main);
  
  window.setTimeout(function() {
    main.innerHTML = "";                                            a = 50;
    for (var i = 0; i < a; i++) {
      block = generateRandomBlock(i);
	  //block.className = "circle";
	  block.style.backgroundColor = generateColor("rgba");
      main.appendChild(block);
    }
	body.appendChild(main);
	main.className = "cubicInOut";
	window.setTimeout(function() { main.removeAttribute("class"); }, 300);
	
    var buttonNext = document.getElementById("button-next");
	buttonNext.preload = prepareNextIteration();
	buttonNext.onclick = function() {
	
	  var button = document.getElementById("button-next");
	  button.className = "button-base cubicInOut invisible";
	  
	  window.sloopy.animate(button.preload.tq, button.preload.pq, true);
	  
	  window.setTimeout(function() {
		button.preload = prepareNextIteration();
		
		window.setTimeout(function() {
		  button.innerHTML = "ready!";
		  button.className = "button-base cubicInOut"; 
		}, 300);
		
	  }, 8100);
	  
	  return false;
	};
	
  }, 300);
  
  return false;
};

var generateRandomBlock = function(i) {
  if (!i) { var i = 0; }
  var block = document.createElement("div");
  block.id = "block-" + i;
  block.style.zIndex = "" + 500 + (i * 500);
  block.style.position = "absolute";
  var HW = Math.round(vw(1.0 + Math.random() * 4.0));
  block.style.height = "" + HW + "px";
  block.style.width = "" + HW + "px";
  block.style.top = "" + (vh(50) - (HW / 2)) + "px";
  block.style.left = "" + (vw(50) - (HW / 2)) + "px";
  return block;
};

var prepareNextIteration = function() {
  var blocks = document.getElementById("main").children;
  
  var TQ = new Array();
  for (var i = 0; i < blocks.length; i++) {
    TQ.push(blocks[i]);
  }
  
  for (var j = 0; j < TQ.length; j++) {
	var N = setRandomSloopyProperties(j);
    window.sloopy.add(TQ[j], N);
  }
  
  PQ = new Array();
  for (var p in N) { PQ.push(p); }
  
  return { tq: TQ, pq: PQ };
};

var setRandomSloopyProperties = function(i) {
  var T = Math.random() * vh(90);
  var L = Math.random() * vw(90);
  if (T / L < 0.25) { T = vh(5) + (Math.random() * vh(85)); }
  if (L / T < 0.25) { L = vw(5) + (Math.random() * vw(85)); }
  if (i && i < 20) { var BR = Math.round(Math.random() * 50); } else { var BR = 0.0; }
  var N = {
    "top": {
      value: T,
	  unit: "px",
	  reset: true
	},
    "left": {
      value: L,
	  unit: "px",
	  reset: true
	},
	"border-radius": {
      value: BR,
	  unit: "%",
	  reset: true
    },
    "rotateX": {
	  value: randomPositiveNegative(360) + randomPositiveNegative(360),
	  unit: "deg",
	  reset: true
	},
    "rotateY": {
	  value: randomPositiveNegative(360) + randomPositiveNegative(360),
	  unit: "deg",
	  reset: true
	},
    "rotateZ": {
	  value: randomPositiveNegative(360) + randomPositiveNegative(360),
	  unit: "deg",
	  reset: true
	},
    "background-color": {
      value: generateColor("rgba"),
	  reset: false
    }
  };
  return N;
};


//Modals XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/*
var getInjectedHTML = function(a) {
  var list = {
    pattern: ""
	+ "<div class=\"modal-text\">&nbsp;â¢ The</div>"
	+ "<div class=\"text-indent\">Â·Â·Â· The</div>"
  }
  return list[a] || "";
};
	
var showModal = function(a) {

  var overlay = document.createElement("div");
  overlay.id = "modal-overlay";
  overlay.onclick = hideModal;
  overlay.setAttribute("class", "cubicInOut invisible");
  
  var box = document.createElement("div");
  box.id = "modal-box";
  box.onclick = hideModal;
  box.style.cssText = "position: fixed !important; top: 0px !important; left: 0px !important;";
  box.innerHTML = getInjectedHTML(a);
  
  overlay.appendChild(box);
  document.getElementById("body").appendChild(overlay);
  
  //Adjust #modal-box's top and left offsets
  box.style.cssText = "position: fixed !important;"
  + " " + "top: " + ((vh(100) - box.offsetHeight) / 2.5) + "px !important;"
  + " " + "left: " + ((vw(100) - box.offsetWidth) / 2) + "px !important;";
  
  overlay.setAttribute("class", "cubicInOut");
  return false;
};

var hideModal = function() {
  var overlay = document.getElementById("modal-overlay");
  if (!overlay) { return false; }
  overlay.setAttribute("class", "cubicInOut invisible");
  window.setTimeout(function() {
    document.getElementById("body").removeChild(overlay);
    overlay.innerHTML = "";
    overlay = null;
  }, 300);
  return false;
};
*/

//Start XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

var loadSequence = function() {

  var html = document.getElementById("html");
  html.style.cssText = "font-size: " + vw(1) + "px";
  cleanElementHTML(html);
  
  //var body = document.getElementById("body");
  //body.setAttribute("class", "cubicInOut invisible");
  
  testSloopySetup();
  
  //window.setTimeout(function() {
  //  body.setAttribute("class", "cubicInOut");
  //  window.setTimeout(function() { 
  //	  body.removeAttribute("class"); 
  //	}, 600);
  //}, 300);
  
  return false;
};
window.onload = loadSequence;
window.onresize = loadSequence;

</script>

</head>

<body id="body">

<div id="button-next" class="button-base cubicInOut" title="Click me to start a new animation loop!" data-clicks="0">ready!</div>
	 
<!-- window.sloopy.setMatrix3D(event.target); console.log(' '); console.log(event.target.animation);
<a id="href-download"> <span id="button-download" class="button-base cubicInOut invisible"> </span> </a> -->

<div id="main" onclick="console.log(' '); window.sloopy.add(event.target, setRandomSloopyProperties()); console.log(event.target.animation);"> </div>
  
</body>

</html>
